"use strict";exports.__esModule = true;exports.MARKO_ALIAS_TYPES = exports.MARKO_TYPES = exports.default = void 0;var _utils = require("@babel/types/lib/definitions/utils");







var _core = require("@babel/types/lib/definitions/core");
const valueFieldCommon = {
  value: {
    validate: (0, _utils.assertValueType)("string") } };



const MarkoDefinitions = {
  MarkoDocumentType: {
    aliases: ["Marko", "Statement"],
    builder: ["value"],
    fields: { ...valueFieldCommon } },


  MarkoDeclaration: {
    aliases: ["Marko", "Statement"],
    builder: ["value"],
    fields: { ...valueFieldCommon } },


  MarkoCDATA: {
    aliases: ["Marko", "Statement"],
    builder: ["value"],
    fields: { ...valueFieldCommon } },


  MarkoComment: {
    aliases: ["Marko", "Statement"],
    builder: ["value"],
    fields: { ...valueFieldCommon } },


  MarkoText: {
    aliases: ["Marko", "Statement"],
    builder: ["value"],
    fields: { ...valueFieldCommon } },


  MarkoPlaceholder: {
    aliases: ["Marko", "Statement"],
    builder: ["value", "escape"],
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertNodeType)("Expression") },

      escape: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: true } } },




  MarkoScriptlet: {
    aliases: ["Marko", "Statement"],
    builder: ["body", "static"],
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.arrayOfType)(["Statement"]) },

      static: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false } } },




  MarkoClass: {
    aliases: ["Marko", "Statement"],
    builder: ["body"],
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody") } } },




  MarkoAttribute: {
    aliases: ["Marko"],
    builder: ["name", "value", "modifier", "arguments", "default", "bound"],
    visitor: ["value", "arguments"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string") },

      value: {
        validate: (0, _utils.assertNodeType)("Expression") },

      modifier: {
        validate: (0, _utils.assertValueType)("string"),
        optional: true },

      arguments: {
        validate: (0, _utils.chain)(
        (0, _utils.assertValueType)("array"),
        (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),

        optional: true },

      default: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true },

      bound: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true } } },




  MarkoSpreadAttribute: {
    aliases: ["Marko"],
    builder: ["value"],
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertNodeType)("Expression") } } },




  MarkoTagBody: {
    aliases: ["Marko", "BlockParent", "Scope"],
    builder: ["body", "params"],
    visitor: ["params", "body"],
    fields: {
      params: {
        ..._core.functionCommon.params,
        default: [] },

      body: {
        validate: (0, _utils.arrayOfType)([
        "MarkoTag",
        "MarkoCDATA",
        "MarkoText",
        "MarkoPlaceholder",
        "MarkoScriptlet",
        "MarkoComment"]),

        default: [] } } },




  MarkoTag: {
    aliases: ["Marko", "Statement"],
    builder: ["name", "attributes", "body", "arguments", "var"],
    visitor: ["name", "attributes", "body", "arguments", "var"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("Expression") },

      attributes: {
        validate: (0, _utils.arrayOfType)(["MarkoAttribute", "MarkoSpreadAttribute"]),
        default: [] },

      body: {
        validate: (0, _utils.assertNodeType)("MarkoTagBody") },

      arguments: {
        validate: (0, _utils.chain)(
        (0, _utils.assertValueType)("array"),
        (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),

        optional: true },

      rawValue: {
        validate: (0, _utils.assertValueType)("string"),
        optional: true },

      var: {
        validate: (0, _utils.assertNodeType)("LVal"),
        optional: true } } } };var _default =





MarkoDefinitions;exports.default = _default;
const MARKO_TYPES = Object.keys(MarkoDefinitions);exports.MARKO_TYPES = MARKO_TYPES;
const MARKO_ALIAS_TYPES = Array.from(
new Set(
MARKO_TYPES.reduce((all, t) => all.concat(MarkoDefinitions[t].aliases), [])));exports.MARKO_ALIAS_TYPES = MARKO_ALIAS_TYPES;
//# sourceMappingURL=definitions.js.map
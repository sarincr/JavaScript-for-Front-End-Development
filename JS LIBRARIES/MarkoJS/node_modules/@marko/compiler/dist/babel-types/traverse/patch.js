"use strict";require("../types/patch");

var t = _interopRequireWildcard(require("@babel/types"));
var _traverse = _interopRequireWildcard(require("@babel/traverse"));
var _definitions = require("../types/definitions");function _getRequireWildcardCache(nodeInterop) {if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function (nodeInterop) {return nodeInterop ? cacheNodeInterop : cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj, nodeInterop) {if (!nodeInterop && obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { default: obj };}var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj.default = obj;if (cache) {cache.set(obj, newObj);}return newObj;}

_definitions.MARKO_TYPES.forEach((typeName) => {
  const checkKey = `is${typeName}`;
  const assertKey = `assert${typeName}`;
  const checkFn = t[checkKey];
  const assertFn = t[assertKey];
  _traverse.NodePath.prototype[checkKey] = function (opts) {
    return checkFn(this.node, opts);
  };
  _traverse.NodePath.prototype[assertKey] = function (opts) {
    assertFn(this.node, opts);
  };
});

_definitions.MARKO_ALIAS_TYPES.forEach((aliasName) => {
  const checkKey = `is${aliasName}`;
  const originalProtoCheck = _traverse.NodePath.prototype[checkKey];
  _traverse.NodePath.prototype[checkKey] = function (opts) {
    return (
      t.is(aliasName, this.node, opts) ||
      originalProtoCheck.call(this, this.node, opts));

  };
});

// Adds a one time patch to the scope collector visitors to include
// Marko bindings for params and tag vars.
const originalCrawl = _traverse.Scope.prototype.crawl;
const patchedVisitors = new WeakSet();

_traverse.Scope.prototype.crawl = function () {
  const path = this.path;
  const originalTraverse = path.traverse;
  path.traverse = function (visitor, state) {
    path.traverse = originalTraverse;

    if (!patchedVisitors.has(visitor)) {
      patchedVisitors.add(visitor);
      Object.assign(
      _traverse.default.explode(visitor),
      _traverse.default.explode({
        MarkoTagBody(body) {
          for (const param of body.get("params")) {
            body.scope.registerBinding("param", param);
          }
        },
        MarkoTag(tag) {
          const tagVar = tag.get("var");
          if (tagVar.node) {
            tag.scope.registerBinding("local", tagVar, tag);
            for (const name in tagVar.getBindingIdentifiers()) {
              let curScope = tag.scope;
              const binding = curScope.getBinding(name);

              while (curScope = curScope.parent) {
                curScope.hoistableTagVars =
                curScope.hoistableTagVars || (
                curScope.hoistableTagVars = {});
                const existingBinding = curScope.hoistableTagVars[name];

                if (existingBinding) {
                  if (existingBinding !== binding) {
                    curScope.hoistableTagVars[name] = true;
                  }
                } else {
                  curScope.hoistableTagVars[name] = binding;
                }
              }
            }
          }
        } }));


    }

    this.traverse(visitor, state);

    if (state.references.length) {
      const movedBindings = new Map();
      for (const ref of state.references) {
        const { name } = ref.node;
        let curScope = ref.scope;
        if (curScope.hasBinding(name)) continue;

        do {
          const hoistableBinding =
          curScope.hoistableTagVars && curScope.hoistableTagVars[name];
          if (hoistableBinding) {
            if (hoistableBinding === true) {
              throw ref.buildCodeFrameError(
              "Ambiguous reference, variable was defined in multiple places and was not shadowed.");

            }

            const movedBinding = movedBindings.get(hoistableBinding);
            if (
            !movedBinding ||
            getScopeDepth(movedBinding) < getScopeDepth(curScope))
            {
              movedBindings.set(hoistableBinding, curScope);
            }
          }
        } while (curScope = curScope.parent);
      }

      for (const [binding, scope] of movedBindings) {
        binding.scope.moveBindingTo(binding.identifier.name, scope);
      }
    }
  };

  originalCrawl.call(this);
  path.traverse = originalTraverse;
};

function getScopeDepth(scope) {
  let depth = 0;
  let cur = scope;
  while (cur = cur.parent) depth++;
  return depth;
}
//# sourceMappingURL=patch.js.map
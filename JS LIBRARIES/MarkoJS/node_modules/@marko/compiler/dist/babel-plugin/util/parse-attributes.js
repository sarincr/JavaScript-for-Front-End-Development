"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.default = void 0;var t = _interopRequireWildcard(require("../../babel-types"));
var _babelUtils = require("@marko/babel-utils");
var _parseArguments = _interopRequireDefault(require("./parse-arguments"));function _getRequireWildcardCache(nodeInterop) {if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function (nodeInterop) {return nodeInterop ? cacheNodeInterop : cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj, nodeInterop) {if (!nodeInterop && obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { default: obj };}var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj.default = obj;if (cache) {cache.set(obj, newObj);}return newObj;}var _default =

(file, attributes, startPos) => {
  const code = file.code;
  let attrEndPos = startPos;

  return attributes.map((attr) => {
    let attrStartPos = attr.default ?
    attr.pos :
    code.indexOf(attr.name, attrEndPos);

    if (attr.name.startsWith("...")) {
      let attrExpression = attr.name.slice(3);

      if (attr.argument) {
        attrExpression += `(${attr.argument.value})`;
      }

      attrEndPos = attrStartPos + attrExpression.length;

      const value = (0, _babelUtils.parseExpression)(file, attrExpression, attrStartPos + 3);

      // TODO: Inline merge object literals.
      return (0, _babelUtils.withLoc)(
      file,
      t.markoSpreadAttribute(value),
      attrStartPos,
      attrEndPos);

    }

    const match = /:(.*)$/.exec(attr.name);
    const modifier = match && match[1];
    let name = attr.name;
    let value;

    if (modifier) {
      name = name.slice(0, name.length - modifier.length - 1);
    }

    if (attr.value) {
      attrEndPos = attr.endPos;

      if (attr.method) {
        if (code[attrStartPos] !== "(") {
          // fix bug in htmljs parser position.
          attrStartPos = code.indexOf("(", attrStartPos);
        }

        if (code[attrEndPos] === "}") {
          // fix bug in htmljs parser position.
          attrEndPos++;
        }

        const prefix = "function";
        value = (0, _babelUtils.parseExpression)(
        file,
        prefix + code.slice(attrStartPos, attrEndPos), // We use the raw value to ignore things like non standard placeholders.
        attrStartPos - prefix.length);

      } else {
        const valueStart = attr.pos + 1; // Add one to account for "=".
        const rawValue = code.slice(valueStart, attrEndPos); // We use the raw value to ignore things like non standard placeholders.

        value = (0, _babelUtils.parseExpression)(file, rawValue, valueStart);
      }
    } else {
      attrEndPos = attr.argument ? attr.argument.endPos + 1 : attr.endPos;
      value = t.booleanLiteral(true);
    }

    return (0, _babelUtils.withLoc)(
    file,
    t.markoAttribute(
    name,
    value,
    modifier,
    (0, _parseArguments.default)(file, attr.argument),
    Boolean(attr.default),
    Boolean(attr.bound)),

    attrStartPos,
    attrEndPos);

  });
};exports.default = _default;
//# sourceMappingURL=parse-attributes.js.map
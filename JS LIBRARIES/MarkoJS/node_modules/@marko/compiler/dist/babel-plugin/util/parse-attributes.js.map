{"version":3,"sources":["../../../src/babel-plugin/util/parse-attributes.js"],"names":["file","attributes","startPos","code","attrEndPos","map","attr","attrStartPos","default","pos","indexOf","name","startsWith","attrExpression","slice","argument","value","length","t","markoSpreadAttribute","match","exec","modifier","endPos","method","prefix","valueStart","rawValue","booleanLiteral","markoAttribute","Boolean","bound"],"mappings":"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","sourcesContent":["import * as t from \"../../babel-types\";\nimport { withLoc, parseExpression } from \"@marko/babel-utils\";\nimport parseArguments from \"./parse-arguments\";\n\nexport default (file, attributes, startPos) => {\n  const code = file.code;\n  let attrEndPos = startPos;\n\n  return attributes.map(attr => {\n    let attrStartPos = attr.default\n      ? attr.pos\n      : code.indexOf(attr.name, attrEndPos);\n\n    if (attr.name.startsWith(\"...\")) {\n      let attrExpression = attr.name.slice(3);\n\n      if (attr.argument) {\n        attrExpression += `(${attr.argument.value})`;\n      }\n\n      attrEndPos = attrStartPos + attrExpression.length;\n\n      const value = parseExpression(file, attrExpression, attrStartPos + 3);\n\n      // TODO: Inline merge object literals.\n      return withLoc(\n        file,\n        t.markoSpreadAttribute(value),\n        attrStartPos,\n        attrEndPos\n      );\n    }\n\n    const match = /:(.*)$/.exec(attr.name);\n    const modifier = match && match[1];\n    let name = attr.name;\n    let value;\n\n    if (modifier) {\n      name = name.slice(0, name.length - modifier.length - 1);\n    }\n\n    if (attr.value) {\n      attrEndPos = attr.endPos;\n\n      if (attr.method) {\n        if (code[attrStartPos] !== \"(\") {\n          // fix bug in htmljs parser position.\n          attrStartPos = code.indexOf(\"(\", attrStartPos);\n        }\n\n        if (code[attrEndPos] === \"}\") {\n          // fix bug in htmljs parser position.\n          attrEndPos++;\n        }\n\n        const prefix = \"function\";\n        value = parseExpression(\n          file,\n          prefix + code.slice(attrStartPos, attrEndPos), // We use the raw value to ignore things like non standard placeholders.\n          attrStartPos - prefix.length\n        );\n      } else {\n        const valueStart = attr.pos + 1; // Add one to account for \"=\".\n        const rawValue = code.slice(valueStart, attrEndPos); // We use the raw value to ignore things like non standard placeholders.\n\n        value = parseExpression(file, rawValue, valueStart);\n      }\n    } else {\n      attrEndPos = attr.argument ? attr.argument.endPos + 1 : attr.endPos;\n      value = t.booleanLiteral(true);\n    }\n\n    return withLoc(\n      file,\n      t.markoAttribute(\n        name,\n        value,\n        modifier,\n        parseArguments(file, attr.argument),\n        Boolean(attr.default),\n        Boolean(attr.bound)\n      ),\n      attrStartPos,\n      attrEndPos\n    );\n  });\n};\n"],"file":"parse-attributes.js"}
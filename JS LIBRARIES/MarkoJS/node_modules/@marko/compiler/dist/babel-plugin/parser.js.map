{"version":3,"sources":["../../src/babel-plugin/parser.js"],"names":["EMPTY_OBJECT","EMPTY_ARRAY","htmlTrimStart","t","replace","htmlTrimEnd","htmlTrim","isAttributeTag","node","isStringLiteral","name","value","parseMarko","file","code","htmlParseOptions","markoOpts","watchFiles","metadata","marko","pushTagBody","getTagBody","pushContainer","currentTag","isProgram","get","preserveWhitespace","path","preservingWhitespaceUntil","wasSelfClosing","handledTagName","onNext","handlers","onDocumentType","pos","endPos","markoDocumentType","onDeclaration","markoDeclaration","onComment","markoComment","onCDATA","markoCDATA","onText","parser","shouldTrim","body","length","prev","prevIndex","isMarkoClass","isMarkoComment","isMarkoScriptlet","undefined","originalValue","indexOf","isMarkoText","test","markoText","prevBody","next","onPlaceholder","escape","withinBody","markoPlaceholder","onScriptlet","line","block","buildCodeFrameError","loc","markoScriptlet","onOpenTagName","event","tagName","tagNameExpression","exec","tagDef","tagNameStartPos","concise","markoTag","stringLiteral","markoTagBody","parseOptions","setParseOptions","rootOnly","onOpenTag","tagNameEndPos","selfClosed","state","enterParsedTextContentState","enterStaticTextContentState","rawOpenTag","set","substring","ignoreAttributes","var","params","argument","shorthandId","shorthandClassNames","attributes","onCloseTag","tag","isConcise","start","end","push","hook","default","parentPath","onfinish","onError","message","includes","isOpenTagOnly","openTagOnly","ignoreNonstandardStringPlaceholders","parse","opts","filename"],"mappings":"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","sourcesContent":["import { createParser } from \"htmljs-parser\";\nimport parseAttributes from \"./util/parse-attributes\";\nimport parseArguments from \"./util/parse-arguments\";\nimport parseParams from \"./util/parse-params\";\nimport parseVar from \"./util/parse-var\";\nimport parseIDShorthand from \"./util/parse-id-shorthand\";\nimport parseClassnameShorthand from \"./util/parse-classname-shorthand\";\nimport * as t from \"../babel-types\";\nimport {\n  withLoc,\n  getLoc,\n  getLocRange,\n  parseScript,\n  parseExpression,\n  getTagDefForTagName\n} from \"@marko/babel-utils\";\n\nconst EMPTY_OBJECT = {};\nconst EMPTY_ARRAY = [];\nconst htmlTrimStart = t => t.replace(/^[\\n\\r]\\s*/, \"\");\nconst htmlTrimEnd = t => t.replace(/[\\n\\r]\\s*$/, \"\");\nconst htmlTrim = t => htmlTrimStart(htmlTrimEnd(t));\nconst isAttributeTag = node =>\n  t.isStringLiteral(node.name) && node.name.value[0] === \"@\";\n\nexport function parseMarko(file) {\n  const { code } = file;\n  const { htmlParseOptions = {} } = file.markoOpts;\n  const { watchFiles } = file.metadata.marko;\n  const pushTagBody = node => getTagBody().pushContainer(\"body\", node);\n  const getTagBody = () =>\n    currentTag.isProgram() ? currentTag : currentTag.get(\"body\");\n  let { preserveWhitespace } = htmlParseOptions;\n  let currentTag = file.path;\n  let preservingWhitespaceUntil = preserveWhitespace;\n  let wasSelfClosing = false;\n  let handledTagName = false;\n  let onNext;\n\n  const handlers = {\n    onDocumentType({ value, pos, endPos }) {\n      const node = withLoc(file, t.markoDocumentType(value), pos, endPos);\n      pushTagBody(node);\n      /* istanbul ignore next */\n      onNext = onNext && onNext(node);\n    },\n\n    onDeclaration({ value, pos, endPos }) {\n      const node = withLoc(file, t.markoDeclaration(value), pos, endPos);\n      pushTagBody(node);\n      /* istanbul ignore next */\n      onNext = onNext && onNext(node);\n    },\n\n    onComment({ value, pos, endPos }) {\n      const node = withLoc(file, t.markoComment(value), pos, endPos);\n      pushTagBody(node);\n      onNext = onNext && onNext(node);\n    },\n\n    onCDATA({ value, pos, endPos }) {\n      const node = withLoc(file, t.markoCDATA(value), pos, endPos);\n      pushTagBody(node);\n      onNext = onNext && onNext(node);\n    },\n\n    onText({ value }, parser) {\n      const shouldTrim = !preservingWhitespaceUntil;\n      const { body } = getTagBody().node;\n      let pos = parser.pos - value.length;\n\n      if (shouldTrim) {\n        if (htmlTrim(value) === \"\") {\n          return;\n        }\n\n        // Find previous non-scriptlet/@tag.\n        let prev;\n        let prevIndex = body.length;\n        while (prevIndex > 0) {\n          prev = body[--prevIndex];\n\n          if (\n            t.isMarkoClass(prev) ||\n            t.isMarkoComment(prev) ||\n            t.isMarkoScriptlet(prev) ||\n            isAttributeTag(prev)\n          ) {\n            prev = undefined;\n          } else {\n            break;\n          }\n        }\n\n        if (!prev) {\n          const originalValue = value;\n          value = htmlTrimStart(value);\n          pos += originalValue.indexOf(value);\n        } else if (\n          t.isMarkoText(prev) &&\n          /\\s/.test(prev.value[prev.value.length - 1])\n        ) {\n          const originalValue = value;\n          value = value.replace(/^\\s+/, \"\");\n          pos += originalValue.indexOf(value);\n        }\n      }\n\n      const endPos = pos + value.length;\n      const node = withLoc(file, t.markoText(value), pos, endPos);\n      const prevBody = getTagBody().node.body;\n      pushTagBody(node);\n      onNext && onNext(node);\n      onNext =\n        shouldTrim &&\n        (next => {\n          if (!next || prevBody.indexOf(next) === -1) {\n            node.value = htmlTrimEnd(node.value);\n          }\n\n          node.value = node.value.replace(/\\s+/g, \" \");\n        });\n    },\n\n    onPlaceholder({ escape, value, withinBody, pos, endPos }) {\n      if (withinBody) {\n        const node = withLoc(\n          file,\n          t.markoPlaceholder(\n            parseExpression(\n              file,\n              value,\n              pos + (escape ? 2 /* ${ */ : 3) /* $!{ */\n            ),\n            escape\n          ),\n          pos,\n          endPos\n        );\n\n        pushTagBody(node);\n        onNext = onNext && onNext(node);\n      }\n    },\n\n    onScriptlet({ value, line, block, pos, endPos }) {\n      if (!line && !block) {\n        throw file.buildCodeFrameError(\n          { loc: getLocRange(file, pos, endPos) },\n          \"<% scriptlets %> are no longer supported.\"\n        );\n      }\n\n      pos -= 1; // Include $.\n      // Scriptlets are ignored as content and don't call `onNext`.\n      pushTagBody(\n        withLoc(\n          file,\n          t.markoScriptlet(\n            parseScript(file, value, pos + 2 /** Ignores leading `$ ` */).body\n          ),\n          pos,\n          endPos\n        )\n      );\n    },\n\n    onOpenTagName(event) {\n      const { pos, endPos } = event;\n      const tagName = event.tagName || \"div\";\n      const [, tagNameExpression] =\n        /^\\$\\{([\\s\\S]*)\\}/.exec(tagName) || EMPTY_ARRAY;\n      const tagDef = !tagNameExpression && getTagDefForTagName(file, tagName);\n      const tagNameStartPos = pos + (event.concise ? 0 : 1); // Account for leading `<`.\n\n      handledTagName = true;\n\n      if (tagNameExpression === \"\") {\n        throw file.buildCodeFrameError(\n          { loc: getLocRange(file, tagNameStartPos + 1, tagNameStartPos + 3) },\n          \"Missing expression for <${dynamic}> tag.\"\n        );\n      }\n\n      const node = withLoc(\n        file,\n        t.markoTag(\n          tagNameExpression\n            ? parseExpression(\n                file,\n                tagNameExpression,\n                tagNameStartPos + 2 /* ${ */\n              )\n            : withLoc(\n                file,\n                t.stringLiteral(tagName),\n                tagNameStartPos,\n                tagNameStartPos + tagName.length\n              ),\n          [],\n          t.markoTagBody()\n        ),\n        pos,\n        endPos\n      );\n\n      if (tagDef) {\n        node.tagDef = tagDef;\n\n        const { parseOptions } = tagDef;\n        if (parseOptions) {\n          event.setParseOptions(parseOptions);\n\n          if (parseOptions.rootOnly && !currentTag.isProgram()) {\n            throw file.buildCodeFrameError(\n              { loc: getLocRange(file, pos, endPos) },\n              `\"${tagName}\" tags must be at the root of your Marko template.`\n            );\n          }\n        }\n      }\n\n      [currentTag] = pushTagBody(node);\n\n      // @tags are not treated as content and do not call next.\n      if (!isAttributeTag(node)) {\n        onNext = onNext && onNext(node);\n      }\n    },\n\n    onOpenTag(event, parser) {\n      if (!handledTagName) {\n        // There is a bug in htmljs parser where a single top level concise mode tag with nothing else\n        // does not emit the openTagNameEvent.\n        handlers.onOpenTagName(event);\n      }\n\n      handledTagName = false;\n      const { pos, endPos, tagNameEndPos } = event;\n      const { tagDef } = currentTag.node;\n      const parseOptions = (tagDef && tagDef.parseOptions) || EMPTY_OBJECT;\n      wasSelfClosing = event.selfClosed;\n\n      if (parseOptions.state === \"parsed-text\") {\n        parser.enterParsedTextContentState();\n      } else if (parseOptions.state === \"static-text\") {\n        parser.enterStaticTextContentState();\n      }\n\n      if (parseOptions.rawOpenTag) {\n        currentTag.set(\n          \"rawValue\",\n          parser.substring(pos, endPos).replace(/^<|\\/>$|>$/g, \"\")\n        );\n      }\n\n      if (!parseOptions.ignoreAttributes) {\n        currentTag.set(\"var\", parseVar(file, event.var));\n        currentTag.get(\"body\").set(\"params\", parseParams(file, event.params));\n        currentTag.set(\"arguments\", parseArguments(file, event.argument));\n        currentTag.set(\n          \"attributes\",\n          parseIDShorthand(\n            file,\n            event.shorthandId,\n            parseClassnameShorthand(\n              file,\n              event.shorthandClassNames,\n              parseAttributes(file, event.attributes, tagNameEndPos)\n            )\n          )\n        );\n      }\n\n      if (!preservingWhitespaceUntil && parseOptions.preserveWhitespace) {\n        preservingWhitespaceUntil = currentTag;\n      }\n    },\n\n    onCloseTag(event, parser) {\n      let { pos, endPos } = event;\n      const tag = currentTag;\n      const { node } = tag;\n      const { tagDef } = node;\n      const isConcise = code[node.start - 1] !== \"<\";\n\n      if (preservingWhitespaceUntil === currentTag) {\n        preservingWhitespaceUntil = undefined;\n      }\n\n      if (!pos) {\n        pos = parser.pos;\n      }\n\n      if (!endPos) {\n        endPos = pos;\n\n        if (wasSelfClosing && !isConcise) {\n          endPos += 2; // account for \"/>\"\n        }\n      }\n\n      node.end = endPos;\n      node.loc.end = getLoc(file, endPos);\n\n      if (\n        !isConcise &&\n        !wasSelfClosing &&\n        code[pos + 1] !== \"/\" &&\n        !currentTag.get(\"name\").isStringLiteral()\n      ) {\n        throw file.buildCodeFrameError(\n          { loc: getLocRange(file, pos, endPos) },\n          `Invalid ending for dynamic tag, expected \"</>\".`\n        );\n      }\n\n      if (tagDef && tagDef.parser) {\n        if (tagDef.parser.path) {\n          watchFiles.push(tagDef.parser.path);\n        }\n        /* istanbul ignore next */\n        (tagDef.parser.hook.default || tagDef.parser.hook)(tag, t);\n      }\n\n      currentTag = currentTag.parentPath.parentPath || file.path;\n    },\n\n    onfinish() {\n      onNext = onNext && onNext();\n    },\n\n    onError({ message, pos, endPos }) {\n      if (message.includes(\"EOF\")) endPos = pos;\n      throw file.buildCodeFrameError(\n        { loc: getLocRange(file, pos, endPos) },\n        message\n      );\n    }\n  };\n\n  createParser(handlers, {\n    isOpenTagOnly(name) {\n      const { parseOptions = EMPTY_OBJECT } =\n        getTagDefForTagName(file, name) || EMPTY_OBJECT;\n      return parseOptions.openTagOnly;\n    },\n    ignoreNonstandardStringPlaceholders: true,\n    ...htmlParseOptions\n  }).parse(code, file.opts.filename);\n}\n"],"file":"parser.js"}
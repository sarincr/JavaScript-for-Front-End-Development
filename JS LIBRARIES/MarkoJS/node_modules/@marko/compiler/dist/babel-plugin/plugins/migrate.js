"use strict";exports.__esModule = true;exports.visitor = void 0;var _babelUtils = require("@marko/babel-utils");
var t = _interopRequireWildcard(require("../../babel-types"));
var _pluginHooks = require("../util/plugin-hooks");function _getRequireWildcardCache(nodeInterop) {if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function (nodeInterop) {return nodeInterop ? cacheNodeInterop : cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj, nodeInterop) {if (!nodeInterop && obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { default: obj };}var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj.default = obj;if (cache) {cache.set(obj, newObj);}return newObj;}

/**
 * Applies custom migrators on tags.
 */
const visitor = {
  MarkoTag: {
    enter(path) {
      const migrators = getMigratorsForTag(path);
      const { node } = path;
      for (const migrator of migrators) {
        (0, _pluginHooks.enter)(migrator, path, t);
        if (path.node !== node) break; // Stop if node is replaced.
      }
    },
    exit(path) {
      const migrators = getMigratorsForTag(path);
      const { node } = path;
      for (const migrator of migrators) {
        (0, _pluginHooks.exit)(migrator, path, t);
        if (path.node !== node) break; // Stop if node is replaced.
      }
    } } };exports.visitor = visitor;



function getMigratorsForTag(path) {
  const {
    hub: { file } } =
  path;
  const { watchFiles } = file.metadata.marko;
  const tagName = path.get("name.value").node || "*";
  const MIGRATOR_CACHE = file.MIGRATOR_CACHE =
  file.MIGRATOR_CACHE || Object.create(null);

  let migrators = MIGRATOR_CACHE[tagName];

  if (!migrators) {
    migrators = MIGRATOR_CACHE[tagName] = [];
    const addMigrators = (tagDef) => {
      if (tagDef && tagDef.migrators) {
        for (const migrator of tagDef.migrators) {
          if (migrator.path) {
            watchFiles.push(migrator.path);
          }
          migrators.push(migrator.hook.default || migrator.hook);
        }
      }
    };

    addMigrators((0, _babelUtils.getTagDef)(path));

    if (tagName !== "*") {
      addMigrators((0, _babelUtils.getTagDefForTagName)(file, "*"));
    }
  }

  return migrators;
}
//# sourceMappingURL=migrate.js.map
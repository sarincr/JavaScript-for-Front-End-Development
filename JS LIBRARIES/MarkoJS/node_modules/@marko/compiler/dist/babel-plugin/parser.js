"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.parseMarko = parseMarko;var _htmljsParser = require("htmljs-parser");
var _parseAttributes = _interopRequireDefault(require("./util/parse-attributes"));
var _parseArguments = _interopRequireDefault(require("./util/parse-arguments"));
var _parseParams = _interopRequireDefault(require("./util/parse-params"));
var _parseVar = _interopRequireDefault(require("./util/parse-var"));
var _parseIdShorthand = _interopRequireDefault(require("./util/parse-id-shorthand"));
var _parseClassnameShorthand = _interopRequireDefault(require("./util/parse-classname-shorthand"));
var t = _interopRequireWildcard(require("../babel-types"));
var _babelUtils = require("@marko/babel-utils");function _getRequireWildcardCache(nodeInterop) {if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function (nodeInterop) {return nodeInterop ? cacheNodeInterop : cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj, nodeInterop) {if (!nodeInterop && obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { default: obj };}var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj.default = obj;if (cache) {cache.set(obj, newObj);}return newObj;}








const EMPTY_OBJECT = {};
const EMPTY_ARRAY = [];
const htmlTrimStart = (t) => t.replace(/^[\n\r]\s*/, "");
const htmlTrimEnd = (t) => t.replace(/[\n\r]\s*$/, "");
const htmlTrim = (t) => htmlTrimStart(htmlTrimEnd(t));
const isAttributeTag = (node) =>
t.isStringLiteral(node.name) && node.name.value[0] === "@";

function parseMarko(file) {
  const { code } = file;
  const { htmlParseOptions = {} } = file.markoOpts;
  const { watchFiles } = file.metadata.marko;
  const pushTagBody = (node) => getTagBody().pushContainer("body", node);
  const getTagBody = () =>
  currentTag.isProgram() ? currentTag : currentTag.get("body");
  let { preserveWhitespace } = htmlParseOptions;
  let currentTag = file.path;
  let preservingWhitespaceUntil = preserveWhitespace;
  let wasSelfClosing = false;
  let handledTagName = false;
  let onNext;

  const handlers = {
    onDocumentType({ value, pos, endPos }) {
      const node = (0, _babelUtils.withLoc)(file, t.markoDocumentType(value), pos, endPos);
      pushTagBody(node);
      /* istanbul ignore next */
      onNext = onNext && onNext(node);
    },

    onDeclaration({ value, pos, endPos }) {
      const node = (0, _babelUtils.withLoc)(file, t.markoDeclaration(value), pos, endPos);
      pushTagBody(node);
      /* istanbul ignore next */
      onNext = onNext && onNext(node);
    },

    onComment({ value, pos, endPos }) {
      const node = (0, _babelUtils.withLoc)(file, t.markoComment(value), pos, endPos);
      pushTagBody(node);
      onNext = onNext && onNext(node);
    },

    onCDATA({ value, pos, endPos }) {
      const node = (0, _babelUtils.withLoc)(file, t.markoCDATA(value), pos, endPos);
      pushTagBody(node);
      onNext = onNext && onNext(node);
    },

    onText({ value }, parser) {
      const shouldTrim = !preservingWhitespaceUntil;
      const { body } = getTagBody().node;
      let pos = parser.pos - value.length;

      if (shouldTrim) {
        if (htmlTrim(value) === "") {
          return;
        }

        // Find previous non-scriptlet/@tag.
        let prev;
        let prevIndex = body.length;
        while (prevIndex > 0) {
          prev = body[--prevIndex];

          if (
          t.isMarkoClass(prev) ||
          t.isMarkoComment(prev) ||
          t.isMarkoScriptlet(prev) ||
          isAttributeTag(prev))
          {
            prev = undefined;
          } else {
            break;
          }
        }

        if (!prev) {
          const originalValue = value;
          value = htmlTrimStart(value);
          pos += originalValue.indexOf(value);
        } else if (
        t.isMarkoText(prev) &&
        /\s/.test(prev.value[prev.value.length - 1]))
        {
          const originalValue = value;
          value = value.replace(/^\s+/, "");
          pos += originalValue.indexOf(value);
        }
      }

      const endPos = pos + value.length;
      const node = (0, _babelUtils.withLoc)(file, t.markoText(value), pos, endPos);
      const prevBody = getTagBody().node.body;
      pushTagBody(node);
      onNext && onNext(node);
      onNext =
      shouldTrim && (
      (next) => {
        if (!next || prevBody.indexOf(next) === -1) {
          node.value = htmlTrimEnd(node.value);
        }

        node.value = node.value.replace(/\s+/g, " ");
      });
    },

    onPlaceholder({ escape, value, withinBody, pos, endPos }) {
      if (withinBody) {
        const node = (0, _babelUtils.withLoc)(
        file,
        t.markoPlaceholder(
        (0, _babelUtils.parseExpression)(
        file,
        value,
        pos + (escape ? 2 /* ${ */ : 3) /* $!{ */),

        escape),

        pos,
        endPos);


        pushTagBody(node);
        onNext = onNext && onNext(node);
      }
    },

    onScriptlet({ value, line, block, pos, endPos }) {
      if (!line && !block) {
        throw file.buildCodeFrameError(
        { loc: (0, _babelUtils.getLocRange)(file, pos, endPos) },
        "<% scriptlets %> are no longer supported.");

      }

      pos -= 1; // Include $.
      // Scriptlets are ignored as content and don't call `onNext`.
      pushTagBody(
      (0, _babelUtils.withLoc)(
      file,
      t.markoScriptlet(
      (0, _babelUtils.parseScript)(file, value, pos + 2 /** Ignores leading `$ ` */).body),

      pos,
      endPos));


    },

    onOpenTagName(event) {
      const { pos, endPos } = event;
      const tagName = event.tagName || "div";
      const [, tagNameExpression] =
      /^\$\{([\s\S]*)\}/.exec(tagName) || EMPTY_ARRAY;
      const tagDef = !tagNameExpression && (0, _babelUtils.getTagDefForTagName)(file, tagName);
      const tagNameStartPos = pos + (event.concise ? 0 : 1); // Account for leading `<`.

      handledTagName = true;

      if (tagNameExpression === "") {
        throw file.buildCodeFrameError(
        { loc: (0, _babelUtils.getLocRange)(file, tagNameStartPos + 1, tagNameStartPos + 3) },
        "Missing expression for <${dynamic}> tag.");

      }

      const node = (0, _babelUtils.withLoc)(
      file,
      t.markoTag(
      tagNameExpression ?
      (0, _babelUtils.parseExpression)(
      file,
      tagNameExpression,
      tagNameStartPos + 2 /* ${ */) :

      (0, _babelUtils.withLoc)(
      file,
      t.stringLiteral(tagName),
      tagNameStartPos,
      tagNameStartPos + tagName.length),

      [],
      t.markoTagBody()),

      pos,
      endPos);


      if (tagDef) {
        node.tagDef = tagDef;

        const { parseOptions } = tagDef;
        if (parseOptions) {
          event.setParseOptions(parseOptions);

          if (parseOptions.rootOnly && !currentTag.isProgram()) {
            throw file.buildCodeFrameError(
            { loc: (0, _babelUtils.getLocRange)(file, pos, endPos) },
            `"${tagName}" tags must be at the root of your Marko template.`);

          }
        }
      }

      [currentTag] = pushTagBody(node);

      // @tags are not treated as content and do not call next.
      if (!isAttributeTag(node)) {
        onNext = onNext && onNext(node);
      }
    },

    onOpenTag(event, parser) {
      if (!handledTagName) {
        // There is a bug in htmljs parser where a single top level concise mode tag with nothing else
        // does not emit the openTagNameEvent.
        handlers.onOpenTagName(event);
      }

      handledTagName = false;
      const { pos, endPos, tagNameEndPos } = event;
      const { tagDef } = currentTag.node;
      const parseOptions = tagDef && tagDef.parseOptions || EMPTY_OBJECT;
      wasSelfClosing = event.selfClosed;

      if (parseOptions.state === "parsed-text") {
        parser.enterParsedTextContentState();
      } else if (parseOptions.state === "static-text") {
        parser.enterStaticTextContentState();
      }

      if (parseOptions.rawOpenTag) {
        currentTag.set(
        "rawValue",
        parser.substring(pos, endPos).replace(/^<|\/>$|>$/g, ""));

      }

      if (!parseOptions.ignoreAttributes) {
        currentTag.set("var", (0, _parseVar.default)(file, event.var));
        currentTag.get("body").set("params", (0, _parseParams.default)(file, event.params));
        currentTag.set("arguments", (0, _parseArguments.default)(file, event.argument));
        currentTag.set(
        "attributes",
        (0, _parseIdShorthand.default)(
        file,
        event.shorthandId,
        (0, _parseClassnameShorthand.default)(
        file,
        event.shorthandClassNames,
        (0, _parseAttributes.default)(file, event.attributes, tagNameEndPos))));



      }

      if (!preservingWhitespaceUntil && parseOptions.preserveWhitespace) {
        preservingWhitespaceUntil = currentTag;
      }
    },

    onCloseTag(event, parser) {
      let { pos, endPos } = event;
      const tag = currentTag;
      const { node } = tag;
      const { tagDef } = node;
      const isConcise = code[node.start - 1] !== "<";

      if (preservingWhitespaceUntil === currentTag) {
        preservingWhitespaceUntil = undefined;
      }

      if (!pos) {
        pos = parser.pos;
      }

      if (!endPos) {
        endPos = pos;

        if (wasSelfClosing && !isConcise) {
          endPos += 2; // account for "/>"
        }
      }

      node.end = endPos;
      node.loc.end = (0, _babelUtils.getLoc)(file, endPos);

      if (
      !isConcise &&
      !wasSelfClosing &&
      code[pos + 1] !== "/" &&
      !currentTag.get("name").isStringLiteral())
      {
        throw file.buildCodeFrameError(
        { loc: (0, _babelUtils.getLocRange)(file, pos, endPos) },
        `Invalid ending for dynamic tag, expected "</>".`);

      }

      if (tagDef && tagDef.parser) {
        if (tagDef.parser.path) {
          watchFiles.push(tagDef.parser.path);
        }
        /* istanbul ignore next */
        (tagDef.parser.hook.default || tagDef.parser.hook)(tag, t);
      }

      currentTag = currentTag.parentPath.parentPath || file.path;
    },

    onfinish() {
      onNext = onNext && onNext();
    },

    onError({ message, pos, endPos }) {
      if (message.includes("EOF")) endPos = pos;
      throw file.buildCodeFrameError(
      { loc: (0, _babelUtils.getLocRange)(file, pos, endPos) },
      message);

    } };


  (0, _htmljsParser.createParser)(handlers, {
    isOpenTagOnly(name) {
      const { parseOptions = EMPTY_OBJECT } =
      (0, _babelUtils.getTagDefForTagName)(file, name) || EMPTY_OBJECT;
      return parseOptions.openTagOnly;
    },
    ignoreNonstandardStringPlaceholders: true,
    ...htmlParseOptions }).
  parse(code, file.opts.filename);
}
//# sourceMappingURL=parser.js.map
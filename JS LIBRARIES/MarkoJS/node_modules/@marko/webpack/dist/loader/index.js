"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const loader_utils_1 = tslib_1.__importDefault(require("loader-utils"));
const escape_string_regexp_1 = tslib_1.__importDefault(require("escape-string-regexp"));
const get_asset_code_1 = tslib_1.__importDefault(require("./get-asset-code"));
const manifest_1 = require("../shared/manifest");
const WATCH_MISSING_FILES = [
    {
        basename: "style",
        has(meta) {
            return Boolean(meta.deps &&
                meta.deps.some(dep => getBasenameWithoutExt((typeof dep === "object" && dep.virtualPath) ||
                    dep) === this.basename));
        }
    },
    {
        basename: "component",
        has(meta) {
            return Boolean(meta.component);
        }
    },
    {
        basename: "component-browser",
        has(meta) {
            return Boolean(meta.deps &&
                meta.deps.some(dep => getBasenameWithoutExt((typeof dep === "object" && dep.virtualPath) ||
                    dep) === this.basename));
        }
    }
];
const DEFAULT_COMPILER = require.resolve("@marko/compiler");
const ADDED_CACHE_CLEAR = new WeakSet();
const ADDED_CUSTOM_TAGLIB = new WeakSet();
async function default_1(source) {
    var _a, _b;
    const { resourcePath, resourceQuery } = this;
    const compiler = getCompiler(this);
    const loaderOptions = loader_utils_1.default.getOptions(this);
    const pluginOptions = compiler.markoPluginOptions || {};
    const sourceMaps = (_a = loaderOptions.sourceMaps) !== null && _a !== void 0 ? _a : this.sourceMap;
    const target = normalizeTarget(loaderOptions.target || this.target);
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const markoCompiler = require(loaderOptions.compiler ||
        DEFAULT_COMPILER);
    const virtualSources = (compiler.markoVirtualSources || (compiler.markoVirtualSources = new Map()));
    this.cacheable(true);
    if (!ADDED_CACHE_CLEAR.has(compiler)) {
        compiler.hooks.watchRun.tap("clearMarkoTaglibCache", () => markoCompiler.taglib.clearCaches());
        ADDED_CACHE_CLEAR.add(compiler);
    }
    if (!ADDED_CUSTOM_TAGLIB.has(markoCompiler)) {
        markoCompiler.taglib.register(__filename, {
            "<head>": {
                transformer: require.resolve("./head-transformer")
            }
        });
        ADDED_CUSTOM_TAGLIB.add(markoCompiler);
    }
    if (resourceQuery === "?manifest") {
        return `export default ${manifest_1.MANIFEST_PLACEHOLDER}`;
    }
    if (virtualSources.has(this.resource)) {
        const { code, map } = virtualSources.get(this.resource);
        virtualSources.delete(this.resource);
        return this.callback(null, code, map);
    }
    const done = this.async();
    try {
        const baseConfig = {
            sourceMaps,
            hot: this.hot,
            fileSystem: this.fs,
            writeVersionComment: false,
            runtimeId: pluginOptions.runtimeId,
            cache: (compiler.markoCompileCache || (compiler.markoCompileCache = new Map())),
            resolveVirtualDependency(resourcePath, { code, map, virtualPath }) {
                const absoluteVirtualPath = `${resourcePath}?virtual=${virtualPath}`;
                virtualSources.set(absoluteVirtualPath, { code, map });
                return `${virtualPath}!=!${__filename}!${absoluteVirtualPath}`;
            },
            babelConfig: {
                ...loaderOptions.babelConfig,
                compact: false,
                comments: false,
                caller: {
                    name: "@marko/webpack/loader",
                    target: this.target,
                    supportsStaticESM: true,
                    supportsDynamicImport: true,
                    supportsTopLevelAwait: true,
                    ...(_b = loaderOptions.babelConfig) === null || _b === void 0 ? void 0 : _b.caller
                }
            }
        };
        if (loaderOptions.hydrateIncludeImports) {
            baseConfig.hydrateIncludeImports = loaderOptions.hydrateIncludeImports;
        }
        if (resourceQuery === "?server-entry") {
            const { code, map } = await markoCompiler.compile(get_asset_code_1.default(resourcePath, pluginOptions.runtimeId, compiler.options.output.publicPath), resourcePath, baseConfig);
            return done(null, code, map);
        }
        if (target === "server") {
            const { code, map, meta } = await markoCompiler.compile(source, resourcePath, baseConfig);
            return done(null, code + getTrailingContent(this, resourcePath, meta), map);
        }
        if (resourceQuery === "?browser-entry") {
            const { code, meta } = await markoCompiler.compile(source, resourcePath, {
                ...baseConfig,
                sourceMaps: false,
                output: "hydrate"
            });
            const mwpVar = `$mwp${pluginOptions.runtimeId ? `_${pluginOptions.runtimeId}` : ""}`;
            const mwpPrefix = compiler.options.output.publicPath === undefined
                ? `if (window.${mwpVar}) __webpack_public_path__ = ${mwpVar};\n`
                : "";
            return done(null, mwpPrefix + code + getTrailingContent(this, resourcePath, meta));
        }
        const { code, meta, map } = await markoCompiler.compile(source, resourcePath, {
            ...baseConfig,
            output: "dom"
        });
        return done(null, code + getTrailingContent(this, resourcePath, meta), map);
    }
    catch (err) {
        done(err);
    }
}
exports.default = default_1;
function getTrailingContent(ctx, resource, meta) {
    let result = "";
    if (meta.watchFiles) {
        for (const watchFile of meta.watchFiles) {
            ctx.addDependency(watchFile);
        }
    }
    if (ctx._compiler.watchMode) {
        const missingDeps = [];
        for (const watchFile of WATCH_MISSING_FILES) {
            if (!watchFile.has(meta)) {
                missingDeps.push(watchFile.basename);
            }
        }
        if (missingDeps.length) {
            const templateFileName = getBasenameWithoutExt(resource);
            result += `\nrequire.context(".", false, /\\${path_1.default.sep}${templateFileName === "index"
                ? ""
                : `${escape_string_regexp_1.default(templateFileName)}\\.`}(?:${missingDeps.join("|")})\\.[^\\${path_1.default.sep}]+$/)`;
        }
    }
    if (ctx.hot) {
        result += "\nif (import.meta.webpackHot) import.meta.webpackHot.accept()";
    }
    return result;
}
function getCompiler(ctx) {
    let compiler = ctx._compiler;
    while (compiler.parentCompilation) {
        compiler = compiler.parentCompilation.compiler;
    }
    return compiler;
}
function getBasenameWithoutExt(file) {
    const baseStart = file.lastIndexOf(path_1.default.sep) + 1;
    const extStart = file.indexOf(".", baseStart + 1);
    return file.slice(baseStart, extStart);
}
function normalizeTarget(target) {
    switch (target) {
        case "server":
        case "node":
        case "async-node":
        case "atom":
        case "electron":
        case "electron-main":
            return "server";
        default:
            return "browser";
    }
}
//# sourceMappingURL=index.js.map
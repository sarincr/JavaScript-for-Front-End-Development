{"version":3,"sources":["../src/tags.js"],"names":["TRANSPARENT_TAGS","Set","CWD","process","cwd","ROOT","isNativeTag","path","node","_isDynamicString","tagDef","getTagDef","html","htmlType","template","renderer","isDynamicTag","t","isStringLiteral","name","isAttributeTag","value","isTransparentTag","has","isMacroTag","Boolean","getMacroIdentifier","macros","hub","file","metadata","marko","id","identifier","getFullyResolvedTagName","parts","cur","push","slice","findParentTag","reverse","join","parentPath","isMarkoTagBody","isMarkoTag","undefined","findAttributeTags","attributeTags","get","forEach","child","getArgOrSequence","arguments","args","len","length","sequenceExpression","isLoopTag","tagName","loadFileForTag","tag","def","fs","markoOpts","fileSystem","filename","___getMarkoFile","readFileSync","toString","createNewFileOpts","opts","loadFileForImport","request","relativeRequest","resolveTagImport","compilerModules","require","resolve","getTemplateId","optimize","update","digest","tagEntry","relativePath","buildCodeFrameError","endsWith","sourceFileName","filenameRelative","parserOpts","generatorOpts"],"mappings":"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","sourcesContent":["import { relative, resolve, basename } from \"path\";\nimport { createHash } from \"crypto\";\nimport { types as t } from \"@marko/compiler\";\nimport * as compilerModules from \"@marko/compiler/modules\";\nimport { getRootDir } from \"lasso-package-root\";\nimport { getTagDefForTagName } from \"./taglib\";\nimport { resolveRelativePath } from \"./imports\";\nconst TRANSPARENT_TAGS = new Set([\n  \"for\",\n  \"while\",\n  \"if\",\n  \"else\",\n  \"else-if\",\n  \"_no-update\"\n]);\n\nconst CWD = process.cwd();\nlet ROOT = CWD;\ntry {\n  ROOT = getRootDir(ROOT) || ROOT;\n  // eslint-disable-next-line no-empty\n} catch {}\n\nexport function isNativeTag(path) {\n  if (path.node._isDynamicString) {\n    return true;\n  }\n\n  const tagDef = getTagDef(path);\n  return (\n    tagDef &&\n    tagDef.html &&\n    (tagDef.htmlType === \"custom-element\" ||\n      (!tagDef.template && !tagDef.renderer))\n  );\n}\n\nexport function isDynamicTag(path) {\n  return !t.isStringLiteral(path.node.name);\n}\n\nexport function isAttributeTag(path) {\n  const {\n    node: { name }\n  } = path;\n  return t.isStringLiteral(name) && name.value[0] === \"@\";\n}\n\nexport function isTransparentTag(path) {\n  const {\n    node: { name }\n  } = path;\n  return t.isStringLiteral(name) && TRANSPARENT_TAGS.has(name.value);\n}\n\nexport function isMacroTag(path) {\n  return Boolean(getMacroIdentifier(path));\n}\n\nexport function getMacroIdentifier(path) {\n  const macros = path.hub.file.metadata.marko.macros;\n  const { name } = path.node;\n\n  if (t.isStringLiteral(name)) {\n    const id = macros[name.value];\n\n    if (id) {\n      return t.identifier(id);\n    }\n  }\n}\n\nexport function getTagDef(path) {\n  const {\n    node,\n    hub: { file }\n  } = path;\n\n  if (!node.tagDef) {\n    if (isDynamicTag(path) || isMacroTag(path)) {\n      node.tagDef = null;\n    } else {\n      node.tagDef =\n        getTagDefForTagName(\n          file,\n          isAttributeTag(path) ? getFullyResolvedTagName(path) : node.name.value\n        ) || null;\n    }\n  }\n\n  return node.tagDef;\n}\n\nexport function getFullyResolvedTagName(path) {\n  const parts = [];\n  let cur;\n  do {\n    cur = path.node.name.value;\n\n    if (isAttributeTag(path)) {\n      parts.push(cur.slice(1));\n    } else {\n      parts.push(cur || \"*\");\n      break;\n    }\n  } while ((path = findParentTag(path)));\n\n  return parts.reverse().join(\":\");\n}\n\nexport function findParentTag(path) {\n  let cur = path.parentPath;\n\n  while (cur.node) {\n    if (cur.isMarkoTagBody()) {\n      cur = cur.parentPath;\n      continue;\n    }\n\n    if (!cur.isMarkoTag()) {\n      cur = undefined;\n      break;\n    }\n\n    if (isTransparentTag(cur)) {\n      cur = cur.parentPath;\n      continue;\n    }\n\n    return cur;\n  }\n}\n\nexport function findAttributeTags(path, attributeTags = []) {\n  path.get(\"body.body\").forEach(child => {\n    if (isAttributeTag(child)) {\n      attributeTags.push(child);\n    } else if (isTransparentTag(child)) {\n      findAttributeTags(child, attributeTags);\n    }\n  });\n\n  return attributeTags;\n}\n\nexport function getArgOrSequence(path) {\n  const {\n    node: { arguments: args }\n  } = path;\n  const len = args && args.length;\n\n  if (len) {\n    if (len > 1) {\n      return t.sequenceExpression(args);\n    } else {\n      return args[0];\n    }\n  }\n}\n\nexport function isLoopTag(path) {\n  if (!path.isMarkoTag()) {\n    return false;\n  }\n\n  const tagName = path.node.name.value;\n  return tagName === \"while\" || tagName === \"for\";\n}\n\nexport function loadFileForTag(tag) {\n  const def = getTagDef(tag);\n  const { file } = tag.hub;\n  const fs = file.markoOpts.fileSystem;\n  const filename = def && def.template;\n\n  if (filename) {\n    return file.___getMarkoFile(\n      fs.readFileSync(filename).toString(\"utf-8\"),\n      createNewFileOpts(file.opts, filename),\n      file.markoOpts\n    );\n  }\n}\n\nexport function loadFileForImport(file, request) {\n  const fs = file.markoOpts.fileSystem;\n  const relativeRequest = resolveTagImport(file.path, request);\n\n  if (relativeRequest) {\n    const filename =\n      relativeRequest[0] === \".\"\n        ? resolve(file.opts.filename, \"..\", relativeRequest)\n        : compilerModules.require.resolve(relativeRequest);\n    return file.___getMarkoFile(\n      fs.readFileSync(filename).toString(\"utf-8\"),\n      createNewFileOpts(file.opts, filename),\n      file.markoOpts\n    );\n  }\n}\n\nexport function getTemplateId(optimize, request) {\n  const id = relative(ROOT, request);\n\n  if (optimize) {\n    return createHash(\"MD5\").update(id).digest(\"base64\").slice(0, 8);\n  }\n\n  return id;\n}\n\nexport function resolveTagImport(path, request) {\n  const {\n    hub: { file }\n  } = path;\n  if (request[0] === \"<\") {\n    const tagName = request.slice(1, -1);\n    const tagDef = getTagDefForTagName(file, tagName);\n    const tagEntry = tagDef && (tagDef.renderer || tagDef.template);\n    const relativePath = tagEntry && resolveRelativePath(file, tagEntry);\n\n    if (!relativePath) {\n      throw path.buildCodeFrameError(\n        `Unable to find entry point for custom tag <${tagName}>.`\n      );\n    }\n\n    return relativePath;\n  }\n\n  if (request.endsWith(\".marko\")) {\n    return resolveRelativePath(file, request);\n  }\n}\n\nfunction createNewFileOpts(opts, filename) {\n  const sourceFileName = basename(filename);\n  const filenameRelative = relative(CWD, filename);\n  return {\n    ...opts,\n    filename,\n    sourceFileName,\n    filenameRelative,\n    parserOpts: {\n      ...opts.parserOpts,\n      sourceFileName\n    },\n    generatorOpts: {\n      ...opts.generatorOpts,\n      filename,\n      sourceFileName\n    }\n  };\n}\n"],"file":"tags.js"}
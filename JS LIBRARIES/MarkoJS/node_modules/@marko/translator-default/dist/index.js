"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.getRuntimeEntryFiles = getRuntimeEntryFiles;exports.translate = exports.analyze = exports.taglibs = void 0;var _path = require("path");
var _compiler = require("@marko/compiler");
var _babelUtils = require("@marko/babel-utils");














var _package = require("marko/package.json");
var _documentType = _interopRequireDefault(require("./document-type"));
var _declaration = _interopRequireDefault(require("./declaration"));
var _cdata = _interopRequireDefault(require("./cdata"));
var _tag = _interopRequireDefault(require("./tag"));
var _text = _interopRequireDefault(require("./text"));
var _placeholder = _interopRequireDefault(require("./placeholder"));
var _comment = _interopRequireDefault(require("./comment"));
var _scriptlet = _interopRequireDefault(require("./scriptlet"));
var _class = _interopRequireDefault(require("./class"));
var _optimizeVdomCreate = require("./util/optimize-vdom-create");
var _optimizeHtmlWrites = require("./util/optimize-html-writes");
var _getComponentFiles = _interopRequireDefault(require("./util/get-component-files"));
var _addDependencies = _interopRequireDefault(require("./util/add-dependencies"));

var _taglib = _interopRequireDefault(require("./taglib"));exports.taglibs = _taglib.default;

const analyze = {
  Program: {
    enter(program) {
      // Pre populate metadata for component files.
      const meta = program.hub.file.metadata.marko;
      (0, _getComponentFiles.default)(program);

      if (!meta.hasComponent && !meta.hasComponentBrowser) {
        meta.hasComponent = program.
        get("body").
        some((child) => child.isMarkoClass());
      }
    },
    exit(program) {
      const { file } = program.hub;
      const meta = file.metadata.marko;
      const { styleFile, packageFile, componentBrowserFile } =
      (0, _getComponentFiles.default)(program);

      if (packageFile) {
        meta.deps.unshift(`package: ${packageFile}`);
      }

      if (styleFile) {
        meta.deps.unshift(styleFile);
      }

      if (meta.hasComponentBrowser) {
        meta.component = componentBrowserFile;
      } else if (meta.hasComponent || meta.hasStatefulTagParams) {
        meta.component = file.opts.filename;
      }

      meta.component =
      meta.component && (0, _babelUtils.resolveRelativePath)(file, meta.component);
      meta.deps = meta.deps.map((filename) =>
      typeof filename === "string" ?
      (0, _babelUtils.resolveRelativePath)(file, filename) :
      filename);


      meta.imports = program.node.body.
      filter((child) => _compiler.types.isImportDeclaration(child)).
      map((child) => child.source.value);
    } },

  MarkoTag(tag) {
    const { file } = tag.hub;
    const tagDef = (0, _babelUtils.getTagDef)(tag);
    // Check if tag uses stateful tag params.
    const meta = tag.hub.file.metadata.marko;

    if (tagDef) {
      if (tagDef.html && !tagDef.template && !tagDef.renderer) {
        if (tagDef.htmlType === "custom-element") {
          if (tagDef.parseOptions && tagDef.parseOptions.import) {
            // TODO: the taglib should be updated to support this as a top level option.
            meta.deps.push(
            (0, _path.resolve)(
            tagDef.dir,
            (0, _path.resolve)(tagDef.dir, tagDef.parseOptions.import)));


          }
        }
      } else if (tag.get("name").isStringLiteral()) {
        const relativePath = resolveRelativeTagEntry(file, tagDef);

        if (relativePath) {
          tag.node.extra = tag.node.extra || {};
          tag.node.extra.relativePath = relativePath;

          if (!meta.tags.includes(relativePath)) {
            meta.tags.push(relativePath);
          }
        }
      }

      if (tagDef.translator && tagDef.translator.path) {
        if (!meta.watchFiles.includes(tagDef.translator.path)) {
          meta.watchFiles.push(tagDef.translator.path);
        }
      }
    }

    if (
    meta.hasStatefulTagParams ||
    (0, _babelUtils.isNativeTag)(tag) ||
    (0, _babelUtils.isMacroTag)(tag) ||
    !tag.get("body").get("params").length)
    {
      return;
    }

    if ((0, _babelUtils.isDynamicTag)(tag)) {
      meta.hasStatefulTagParams = true;
      return;
    }

    let curTag = tag;
    while ((0, _babelUtils.isAttributeTag)(curTag)) {
      curTag = (0, _babelUtils.findParentTag)(curTag);
    }

    const tagFile = (0, _babelUtils.loadFileForTag)(curTag);
    const childMeta = tagFile && tagFile.metadata.marko;
    meta.hasStatefulTagParams =
    childMeta && (
    childMeta.hasStatefulTagParams ||
    childMeta.hasComponent && !childMeta.hasComponentBrowser);
  },
  ImportDeclaration: {
    exit(path) {
      const source = path.get("source");
      const tagEntry = (0, _babelUtils.resolveTagImport)(source, source.node.value);

      if (tagEntry) {
        const meta = path.hub.file.metadata.marko;
        source.node.value = tagEntry;

        if (!meta.tags.includes(tagEntry)) {
          meta.tags.push(tagEntry);
        }
      }
    } } };exports.analyze = analyze;



const translate = {
  MarkoDocumentType: _documentType.default,
  MarkoDeclaration: _declaration.default,
  MarkoCDATA: _cdata.default,
  MarkoTag: _tag.default,
  MarkoText: _text.default,
  MarkoPlaceholder: _placeholder.default,
  MarkoScriptlet: _scriptlet.default,
  MarkoClass: _class.default,
  MarkoComment: _comment.default,
  ReferencedIdentifier(path) {
    if (path.node.name === "component" && !path.scope.hasBinding("component")) {
      path.replaceWith(path.hub.file._componentInstanceIdentifier);
    }
  },
  Program: {
    enter(path) {
      const {
        hub: { file } } =
      path;

      if (file.markoOpts.output === "hydrate") {
        (0, _addDependencies.default)(file, true);
        return;
      } else if (
      file.markoOpts.resolveVirtualDependency &&
      file.markoOpts.output !== "html")
      {
        (0, _addDependencies.default)(file, false);
      }

      if (file.metadata.marko.moduleCode) {
        path.
        replaceWith((0, _babelUtils.parseScript)(file, file.metadata.marko.moduleCode))[0].
        skip();
        return;
      }

      file._componentDefIdentifier =
      path.scope.generateUidIdentifier("componentDef");

      file._componentInstanceIdentifier =
      path.scope.generateUidIdentifier("component");

      // Pre-Analyze tree
      (0, _optimizeVdomCreate.analyzeStaticVDOM)(path);

      // Move non static content into the renderBody.
      const [renderBlock] = path.pushContainer("body", _compiler.types.blockStatement([]));
      path.
      get("body").
      filter(isRenderContent).
      forEach((childPath) => {
        renderBlock.pushContainer("body", childPath.node);
        childPath.remove();
      });

      file._renderBlock = renderBlock;
      path.scope.crawl();
    },
    exit(path) {
      const {
        hub: { file } } =
      path;
      const { markoOpts, _inlineComponentClass } = file;
      const includeMetaInSource = markoOpts.meta !== false;
      const meta = file.metadata.marko;
      const { componentFile, componentBrowserFile } = (0, _getComponentFiles.default)(path);
      const isHTML = markoOpts.output === "html";

      const renderBlock = file._renderBlock;
      const componentClass =
      componentFile &&
      (0, _babelUtils.importDefault)(
      file,
      (0, _babelUtils.resolveRelativePath)(file, componentFile),
      "marko_component") ||

      _inlineComponentClass ||
      _compiler.types.objectExpression([]);

      const componentIdentifier =
      path.scope.generateUidIdentifier("marko_component");
      const componentTypeIdentifier = path.scope.generateUidIdentifier(
      "marko_componentType");

      const templateIdentifier =
      path.scope.generateUidIdentifier("marko_template");
      const rendererIdentifier = (0, _babelUtils.importDefault)(
      file,
      "marko/src/runtime/components/renderer",
      "marko_renderer");

      const templateRendererMember = _compiler.types.memberExpression(
      templateIdentifier,
      _compiler.types.identifier("_"));

      const templateMetaMember = _compiler.types.memberExpression(
      templateIdentifier,
      _compiler.types.identifier("meta"));


      if (markoOpts.writeVersionComment) {
        path.addComment(
        "leading",
        ` Compiled using marko@${_package.version} - DO NOT EDIT`,
        true);

      }

      const runtimeTemplateIdentifier = path.scope.generateUidIdentifier("t");

      path.unshiftContainer(
      "body",
      [
      _compiler.types.importDeclaration(
      [_compiler.types.importSpecifier(runtimeTemplateIdentifier, _compiler.types.identifier("t"))],
      _compiler.types.stringLiteral(
      `marko/${markoOpts.optimize ? "dist" : "src"}/runtime/${
      isHTML ? "html" : "vdom"
      }${markoOpts.hot ? "/hot-reload" : ""}`)),


      _compiler.types.variableDeclaration("const", [
      _compiler.types.variableDeclarator(
      componentTypeIdentifier,
      _compiler.types.stringLiteral(meta.id)),

      _compiler.types.variableDeclarator(
      templateIdentifier,
      _compiler.types.callExpression(runtimeTemplateIdentifier, [
      componentTypeIdentifier]))]),



      includeMetaInSource &&
      _compiler.types.expressionStatement(
      _compiler.types.assignmentExpression(
      "=",
      _compiler.types.memberExpression(templateIdentifier, _compiler.types.identifier("path")),
      _compiler.types.identifier("__filename"))),


      _compiler.types.exportDefaultDeclaration(templateIdentifier)].
      filter(Boolean));


      path.pushContainer(
      "body",
      [
      !isHTML &&
      _compiler.types.expressionStatement(
      _compiler.types.callExpression(
      (0, _babelUtils.importNamed)(
      file,
      "marko/src/runtime/components/registry",
      "r",
      "marko_registerComponent"),

      [
      componentTypeIdentifier,
      _compiler.types.arrowFunctionExpression(
      [],
      componentBrowserFile ?
      (0, _babelUtils.importDefault)(
      file,
      (0, _babelUtils.resolveRelativePath)(file, componentBrowserFile),
      "marko_split_component") :

      templateIdentifier)])),




      _compiler.types.variableDeclaration("const", [
      _compiler.types.variableDeclarator(componentIdentifier, componentClass)])].

      filter(Boolean));


      const templateRenderOptionsProps = [
      _compiler.types.objectProperty(_compiler.types.identifier("t"), componentTypeIdentifier)];


      if (!meta.component) {
        templateRenderOptionsProps.push(
        _compiler.types.objectProperty(_compiler.types.identifier("i"), _compiler.types.booleanLiteral(true)));

      }

      if (componentBrowserFile) {
        templateRenderOptionsProps.push(
        _compiler.types.objectProperty(_compiler.types.identifier("s"), _compiler.types.booleanLiteral(true)));

      }

      if (!markoOpts.optimize) {
        templateRenderOptionsProps.push(
        _compiler.types.objectProperty(_compiler.types.identifier("d"), _compiler.types.booleanLiteral(true)));

      }

      path.pushContainer(
      "body",
      _compiler.types.expressionStatement(
      _compiler.types.assignmentExpression(
      "=",
      templateRendererMember,
      _compiler.types.callExpression(rendererIdentifier, [
      _compiler.types.functionExpression(
      null,
      [
      _compiler.types.identifier("input"),
      _compiler.types.identifier("out"),
      file._componentDefIdentifier,
      file._componentInstanceIdentifier,
      _compiler.types.identifier("state")],

      renderBlock.node),

      _compiler.types.objectExpression(templateRenderOptionsProps),
      componentIdentifier]))));




      renderBlock.remove();

      if (!isHTML) {
        path.pushContainer(
        "body",
        _compiler.types.expressionStatement(
        _compiler.types.assignmentExpression(
        "=",
        _compiler.types.memberExpression(templateIdentifier, _compiler.types.identifier("Component")),
        _compiler.types.callExpression(
        (0, _babelUtils.importDefault)(
        file,
        "marko/src/runtime/components/defineComponent",
        "marko_defineComponent"),

        [componentIdentifier, templateRendererMember]))));




      }

      if (includeMetaInSource) {
        const metaObject = _compiler.types.objectExpression([
        _compiler.types.objectProperty(_compiler.types.identifier("id"), componentTypeIdentifier)]);


        if (meta.component) {
          metaObject.properties.push(
          _compiler.types.objectProperty(
          _compiler.types.identifier("component"),
          _compiler.types.stringLiteral(meta.component)));


        }

        if (meta.deps.length) {
          metaObject.properties.push(
          _compiler.types.objectProperty(
          _compiler.types.identifier("deps"),
          (0, _babelUtils.parseExpression)(file, JSON.stringify(meta.deps), file.code.length)));


        }

        if (meta.tags.length) {
          metaObject.properties.push(
          _compiler.types.objectProperty(
          _compiler.types.identifier("tags"),
          _compiler.types.arrayExpression(meta.tags.map((tag) => _compiler.types.stringLiteral(tag)))));


        }

        path.pushContainer(
        "body",
        _compiler.types.expressionStatement(
        _compiler.types.assignmentExpression("=", templateMetaMember, metaObject)));


      }

      (0, _optimizeHtmlWrites.optimizeHTMLWrites)(path);
    } } };exports.translate = translate;



function getRuntimeEntryFiles(output, optimize) {
  const base = `marko/${optimize ? "dist" : "src"}/`;

  return [
  `${base}runtime/components`,
  `${base}runtime/components/defineComponent`,
  `${base}runtime/components/renderer`,
  `${base}runtime/components/registry`,
  `${base}runtime/components/attach-detach`,
  `${base}runtime/helpers/assign`,
  `${base}runtime/helpers/class-value`,
  `${base}runtime/helpers/dynamic-tag`,
  `${base}runtime/helpers/load-nested-tag`,
  `${base}runtime/helpers/merge`,
  `${base}runtime/helpers/render-tag`,
  `${base}runtime/helpers/style-value`,
  `${base}runtime/helpers/to-string`,
  `${base}core-tags/components/preserve-tag`,
  `${base}core-tags/components/init-components-tag`,
  `${base}core-tags/components/preferred-script-location-tag`,
  `${base}core-tags/core/__flush_here_and_after__`,
  `${base}core-tags/core/await/renderer`,
  `${base}core-tags/core/await/reorderer-renderer`,
  ...(output === "html" ?
  [
  `${base}runtime/html`,
  `${base}runtime/html/hot-reload`,
  `${base}runtime/html/helpers/attr`,
  `${base}runtime/html/helpers/attrs`,
  `${base}runtime/html/helpers/class-attr`,
  `${base}runtime/html/helpers/data-marko`,
  `${base}runtime/html/helpers/escape-quotes`,
  `${base}runtime/html/helpers/escape-script-placeholder`,
  `${base}runtime/html/helpers/escape-style-placeholder`,
  `${base}runtime/html/helpers/escape-xml`,
  `${base}runtime/html/helpers/merge-attrs`,
  `${base}runtime/html/helpers/props-script`,
  `${base}runtime/html/helpers/style-attr`] :

  [
  `${base}runtime/vdom`,
  `${base}runtime/vdom/hot-reload`,
  `${base}runtime/vdom/helpers/attrs`,
  `${base}runtime/vdom/helpers/const`,
  `${base}runtime/vdom/helpers/v-element`,
  `${base}runtime/vdom/helpers/v-text`,
  `${base}runtime/vdom/preserve-attrs`])];


}

function isRenderContent(path) {
  const { node } = path;
  return _compiler.types.MARKO_TYPES.includes(node.type) && !node.static;
}

function resolveRelativeTagEntry(file, tagDef) {
  // TODO: support transform and other entries.
  const entry = tagDef.template || tagDef.renderer;
  return entry && (0, _babelUtils.resolveRelativePath)(file, entry);
}
//# sourceMappingURL=index.js.map
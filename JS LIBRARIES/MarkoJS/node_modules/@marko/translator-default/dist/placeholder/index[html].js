"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.default = _default;var _compiler = require("@marko/compiler");
var _babelUtils = require("@marko/babel-utils");
var _toString = _interopRequireDefault(require("marko/src/runtime/helpers/to-string"));
var _escapeXml = require("marko/src/runtime/html/helpers/escape-xml");
var _escapeScriptPlaceholder = _interopRequireDefault(require("marko/src/runtime/html/helpers/escape-script-placeholder"));
var _escapeStylePlaceholder = _interopRequireDefault(require("marko/src/runtime/html/helpers/escape-style-placeholder"));
var _htmlOutWrite = _interopRequireDefault(require("../util/html-out-write"));
var _withPreviousLocation = _interopRequireDefault(require("../util/with-previous-location"));

const ESCAPE_TYPES = {
  html: {
    name: "x",
    module: "marko/src/runtime/html/helpers/escape-xml",
    alias: "marko_escapeXml",
    fn: _escapeXml.x },

  script: {
    module: "marko/src/runtime/html/helpers/escape-script-placeholder",
    alias: "marko_escapeScript",
    fn: _escapeScriptPlaceholder.default },

  style: {
    module: "marko/src/runtime/html/helpers/escape-style-placeholder",
    alias: "marko_escapeStyle",
    fn: _escapeStylePlaceholder.default } };



function _default(path) {
  const {
    node,
    hub: { file } } =
  path;
  const { confident, value: computed } = path.get("value").evaluate();
  let { escape, value } = node;

  if (escape) {
    const tagName = findParentTagName(path);
    const escapeType = ESCAPE_TYPES[tagName] || ESCAPE_TYPES.html;

    value = confident ?
    _compiler.types.stringLiteral(escapeType.fn(computed)) :
    _compiler.types.callExpression(
    escapeType.name ?
    (0, _babelUtils.importNamed)(
    file,
    escapeType.module,
    escapeType.name,
    escapeType.alias) :

    (0, _babelUtils.importDefault)(file, escapeType.module, escapeType.alias),
    [value]);

  } else {
    value = confident ?
    _compiler.types.stringLiteral((0, _toString.default)(computed)) :
    _compiler.types.callExpression(
    (0, _babelUtils.importDefault)(
    file,
    "marko/src/runtime/helpers/to-string",
    "marko_to_string"),

    [value]);

  }

  const replacement = (0, _htmlOutWrite.default)`${value}`;

  if (replacement) {
    path.replaceWith((0, _withPreviousLocation.default)(replacement, node));
  } else {
    path.remove();
  }
}

function findParentTagName(path) {
  while (path = path.parentPath) {
    if (path.isProgram()) {
      return;
    }

    if (path.isMarkoTag()) {
      const tagDef = (0, _babelUtils.getTagDef)(path);
      return tagDef && tagDef.html && path.get("name.value").node;
    }
  }
}
//# sourceMappingURL=index[html].js.map
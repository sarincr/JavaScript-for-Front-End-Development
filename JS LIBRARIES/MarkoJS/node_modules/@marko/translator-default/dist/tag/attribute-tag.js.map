{"version":3,"sources":["../../src/tag/attribute-tag.js"],"names":["EMPTY_OBJECT","parentIdentifierLookup","WeakMap","path","node","namePath","get","tagName","value","parentPath","buildCodeFrameError","parentAttributes","tagDef","isRepeated","targetProperty","slice","isDynamic","exampleAttributeTag","hasDynamicAttrTags","body","i","length","child","isAttributeTagChild","insertAfter","t","stringLiteral","some","attr","attrs","isNullLiteral","objectExpression","pushContainer","markoAttribute","remove","identifiers","set","identifier","scope","generateUidIdentifier","unshiftContainer","variableDeclaration","variableDeclarator","arrayExpression","nullLiteral","replaceWith","expressionStatement","callExpression","memberExpression","assignmentExpression","tag"],"mappings":"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","sourcesContent":["import { types as t } from \"@marko/compiler\";\nimport {\n  findParentTag,\n  assertNoArgs,\n  getTagDef,\n  isTransparentTag,\n  isAttributeTag\n} from \"@marko/babel-utils\";\nimport { getAttrs } from \"./util\";\nimport withPreviousLocation from \"../util/with-previous-location\";\n\nconst EMPTY_OBJECT = {};\nconst parentIdentifierLookup = new WeakMap();\n\n// TODO: optimize inline repeated @tags.\n\nexport default function (path) {\n  const { node } = path;\n  const namePath = path.get(\"name\");\n  const tagName = namePath.node.value;\n  const parentPath = findParentTag(path);\n\n  assertNoArgs(path);\n\n  if (!parentPath) {\n    throw namePath.buildCodeFrameError(\n      \"@tags must be nested within another element.\"\n    );\n  }\n\n  const parentAttributes = parentPath.get(\"attributes\");\n  const tagDef = getTagDef(path);\n  const { isRepeated, targetProperty = tagName.slice(1) } =\n    tagDef || EMPTY_OBJECT;\n  const isDynamic = isRepeated || parentPath !== path.parentPath.parentPath;\n  parentPath.node.exampleAttributeTag = node;\n\n  if (isDynamic) {\n    if (!parentPath.node.hasDynamicAttrTags) {\n      const body = parentPath.get(\"body\").get(\"body\");\n      parentPath.node.hasDynamicAttrTags = true;\n\n      for (let i = body.length; i--; ) {\n        const child = body[i];\n        if (isAttributeTagChild(child)) {\n          child.insertAfter(t.stringLiteral(\"END_ATTRIBUTE_TAGS\"));\n          break;\n        }\n      }\n    }\n  } else {\n    if (\n      parentAttributes.some(attr => attr.get(\"name\").node === targetProperty)\n    ) {\n      throw namePath.buildCodeFrameError(\n        `Only one \"${tagName}\" tag is allowed here.`\n      );\n    }\n\n    let attrs = getAttrs(path);\n\n    if (t.isNullLiteral(attrs)) {\n      // TODO: this could be left as a null literal, but would require changes in the\n      // await tag runtime to handle `<@catch/>`. (this would be a breaking change though)\n      attrs = t.objectExpression([]);\n    }\n\n    parentPath.pushContainer(\n      \"attributes\",\n      t.markoAttribute(targetProperty, attrs)\n    );\n\n    path.remove();\n    return;\n  }\n\n  let identifiers = parentIdentifierLookup.get(parentPath);\n\n  if (!identifiers) {\n    parentIdentifierLookup.set(parentPath, (identifiers = {}));\n  }\n\n  let identifier = identifiers[targetProperty];\n\n  if (!identifier) {\n    identifier = identifiers[targetProperty] =\n      path.scope.generateUidIdentifier(targetProperty);\n    parentPath\n      .get(\"body\")\n      .unshiftContainer(\n        \"body\",\n        t.variableDeclaration(isRepeated ? \"const\" : \"let\", [\n          t.variableDeclarator(\n            identifier,\n            isRepeated ? t.arrayExpression([]) : t.nullLiteral()\n          )\n        ])\n      );\n    parentPath.pushContainer(\n      \"attributes\",\n      t.markoAttribute(targetProperty, identifier)\n    );\n  }\n\n  if (isRepeated) {\n    path.replaceWith(\n      withPreviousLocation(\n        t.expressionStatement(\n          t.callExpression(\n            t.memberExpression(identifier, t.identifier(\"push\")),\n            [getAttrs(path)]\n          )\n        ),\n        node\n      )\n    );\n  } else {\n    path.replaceWith(\n      withPreviousLocation(\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", identifier, getAttrs(path))\n        ),\n        node\n      )\n    );\n  }\n}\n\nfunction isAttributeTagChild(tag) {\n  if (isAttributeTag(tag)) {\n    return true;\n  }\n\n  if (isTransparentTag(tag)) {\n    const body = tag.get(\"body\").get(\"body\");\n    return isAttributeTagChild(body[body.length - 1]);\n  }\n\n  return false;\n}\n"],"file":"attribute-tag.js"}
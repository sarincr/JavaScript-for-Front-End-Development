"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.tagArguments = tagArguments;exports.default = _default;var _compiler = require("@marko/compiler");
var _vdomOutWrite = _interopRequireDefault(require("../../util/vdom-out-write"));
var FLAGS = _interopRequireWildcard(require("../../util/runtime-flags"));
var _util = require("../util");
var _babelUtils = require("@marko/babel-utils");




var _withPreviousLocation = _interopRequireDefault(require("../../util/with-previous-location"));function _getRequireWildcardCache(nodeInterop) {if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function (nodeInterop) {return nodeInterop ? cacheNodeInterop : cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj, nodeInterop) {if (!nodeInterop && obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { default: obj };}var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj.default = obj;if (cache) {cache.set(obj, newObj);}return newObj;}

const SIMPLE_ATTRS = ["id", "class", "style"];
const MAYBE_SVG = {
  a: true,
  script: true,
  style: true,
  title: true };


function tagArguments(path, isStatic) {
  const {
    hub: { file },
    node,
    parent } =
  path;
  const {
    name,
    key,
    body: { body },
    handlers } =
  node;
  const tagProperties = path.node.extra && path.node.extra.properties || [];
  let runtimeFlags = 0;

  path.get("attributes").forEach((attr) => {
    const { confident, computed } = (0, _util.evaluateAttr)(attr);

    if (confident) {
      if (computed == null || computed === false) {
        attr.remove();
      } else {
        attr.set("value", _compiler.types.stringLiteral(computed));
      }
    }
  });

  let attrsObj = (0, _util.getAttrs)(path, true, true);

  if (!_compiler.types.isNullLiteral(attrsObj)) {
    if (
    !_compiler.types.isObjectExpression(attrsObj) ||
    attrsObj.properties.some(_compiler.types.isSpreadElement))
    {
      runtimeFlags |= FLAGS.SPREAD_ATTRS;
      attrsObj = _compiler.types.callExpression(
      (0, _babelUtils.importDefault)(
      file,
      "marko/src/runtime/vdom/helpers/attrs",
      "marko_attrs"),

      [attrsObj]);

    }
  }

  const writeArgs = [
  name,
  attrsObj,
  !key && isStatic ? _compiler.types.nullLiteral() : key,
  isStatic ? _compiler.types.nullLiteral() : file._componentInstanceIdentifier,
  isStatic ?
  _compiler.types.numericLiteral(body.length) :
  body.length ?
  _compiler.types.nullLiteral() :
  _compiler.types.numericLiteral(0)];


  if (node.preserveAttrs) {
    tagProperties.push(
    _compiler.types.objectProperty(
    _compiler.types.identifier("pa"),
    _compiler.types.arrayExpression(node.preserveAttrs.map((name) => _compiler.types.stringLiteral(name)))));


  }

  if (handlers) {
    Object.entries(handlers).forEach(
    ([eventName, { arguments: args, once }]) => {
      const delegateArgs = [_compiler.types.stringLiteral(eventName), args[0]];

      // TODO: look into only sending this if once is true.
      delegateArgs.push(_compiler.types.booleanLiteral(once));

      if (args.length > 1) {
        delegateArgs.push(_compiler.types.arrayExpression(args.slice(1)));
      }

      // TODO: why do we output eventName twice.
      tagProperties.push(
      _compiler.types.objectProperty(
      _compiler.types.stringLiteral(`on${eventName}`),
      _compiler.types.callExpression(
      _compiler.types.memberExpression(
      file._componentDefIdentifier,
      _compiler.types.identifier("d")),

      delegateArgs)));



    });

  }

  if (
  _compiler.types.isObjectExpression(attrsObj) &&
  attrsObj.properties.every((n) => isPropertyName(n, SIMPLE_ATTRS)) &&
  !node.preserveAttrs)
  {
    runtimeFlags |= FLAGS.HAS_SIMPLE_ATTRS;
  }

  const tagDef = (0, _babelUtils.getTagDef)(path);

  if (tagDef) {
    const { htmlType, name } = tagDef;
    if (htmlType === "custom-element") {
      runtimeFlags |= FLAGS.IS_CUSTOM_ELEMENT;
    } else if (
    htmlType === "svg" ||
    MAYBE_SVG[name] &&
    _compiler.types.isMarkoTag(parent) &&
    parent.tagDef &&
    parent.tagDef.htmlType === "svg")
    {
      runtimeFlags |= FLAGS.IS_SVG;
    } else if (name === "textarea") {
      runtimeFlags |= FLAGS.IS_TEXTAREA;
    }
  }

  writeArgs.push(_compiler.types.numericLiteral(runtimeFlags));

  if (tagProperties.length) {
    writeArgs.push(_compiler.types.objectExpression(tagProperties));
  }
  return writeArgs;
}

/**
 * Translates the html streaming version of a standard html element.
 */
function _default(path, isNullable) {
  const { node } = path;
  const {
    name,
    key,
    body: { body } } =
  node;

  const isEmpty = !body.length;
  const writeArgs = tagArguments(path, false);
  let writeStartNode = (0, _withPreviousLocation.default)(
  (0, _vdomOutWrite.default)(isEmpty ? "e" : "be", ...writeArgs),
  node.name);


  if (isNullable) {
    writeStartNode = _compiler.types.ifStatement(
    name,
    writeStartNode,
    _compiler.types.expressionStatement(
    _compiler.types.callExpression(
    _compiler.types.memberExpression(_compiler.types.identifier("out"), _compiler.types.identifier("bf")),
    [
    (0, _babelUtils.normalizeTemplateString)`f_${key}`,
    path.hub.file._componentInstanceIdentifier])));




  }

  if (isEmpty) {
    path.replaceWith(writeStartNode);
    return;
  }

  let writeEndNode = (0, _vdomOutWrite.default)("ee");
  if (isNullable) {
    writeEndNode = _compiler.types.ifStatement(
    name,
    writeEndNode,
    _compiler.types.expressionStatement(
    _compiler.types.callExpression(
    _compiler.types.memberExpression(_compiler.types.identifier("out"), _compiler.types.identifier("ef")),
    [])));



  }

  let needsBlock;
  for (const childNode of body) {
    if (_compiler.types.isVariableDeclaration(childNode)) {
      if (childNode.kind === "const" || childNode.kind === "let") {
        needsBlock = true;
        break;
      }
    }
  }

  path.replaceWithMultiple(
  [writeStartNode].
  concat(needsBlock ? _compiler.types.blockStatement(body) : body).
  concat(writeEndNode));

}

function isPropertyName({ key }, names) {
  if (_compiler.types.isStringLiteral(key)) {
    return names.includes(key.value);
  } else if (_compiler.types.isIdentifier(key)) {
    return names.includes(key.name);
  }
}
//# sourceMappingURL=index.js.map
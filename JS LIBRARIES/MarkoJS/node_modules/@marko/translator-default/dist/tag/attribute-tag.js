"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.default = _default;var _compiler = require("@marko/compiler");
var _babelUtils = require("@marko/babel-utils");






var _util = require("./util");
var _withPreviousLocation = _interopRequireDefault(require("../util/with-previous-location"));

const EMPTY_OBJECT = {};
const parentIdentifierLookup = new WeakMap();

// TODO: optimize inline repeated @tags.

function _default(path) {
  const { node } = path;
  const namePath = path.get("name");
  const tagName = namePath.node.value;
  const parentPath = (0, _babelUtils.findParentTag)(path);

  (0, _babelUtils.assertNoArgs)(path);

  if (!parentPath) {
    throw namePath.buildCodeFrameError(
    "@tags must be nested within another element.");

  }

  const parentAttributes = parentPath.get("attributes");
  const tagDef = (0, _babelUtils.getTagDef)(path);
  const { isRepeated, targetProperty = tagName.slice(1) } =
  tagDef || EMPTY_OBJECT;
  const isDynamic = isRepeated || parentPath !== path.parentPath.parentPath;
  parentPath.node.exampleAttributeTag = node;

  if (isDynamic) {
    if (!parentPath.node.hasDynamicAttrTags) {
      const body = parentPath.get("body").get("body");
      parentPath.node.hasDynamicAttrTags = true;

      for (let i = body.length; i--;) {
        const child = body[i];
        if (isAttributeTagChild(child)) {
          child.insertAfter(_compiler.types.stringLiteral("END_ATTRIBUTE_TAGS"));
          break;
        }
      }
    }
  } else {
    if (
    parentAttributes.some((attr) => attr.get("name").node === targetProperty))
    {
      throw namePath.buildCodeFrameError(
      `Only one "${tagName}" tag is allowed here.`);

    }

    let attrs = (0, _util.getAttrs)(path);

    if (_compiler.types.isNullLiteral(attrs)) {
      // TODO: this could be left as a null literal, but would require changes in the
      // await tag runtime to handle `<@catch/>`. (this would be a breaking change though)
      attrs = _compiler.types.objectExpression([]);
    }

    parentPath.pushContainer(
    "attributes",
    _compiler.types.markoAttribute(targetProperty, attrs));


    path.remove();
    return;
  }

  let identifiers = parentIdentifierLookup.get(parentPath);

  if (!identifiers) {
    parentIdentifierLookup.set(parentPath, identifiers = {});
  }

  let identifier = identifiers[targetProperty];

  if (!identifier) {
    identifier = identifiers[targetProperty] =
    path.scope.generateUidIdentifier(targetProperty);
    parentPath.
    get("body").
    unshiftContainer(
    "body",
    _compiler.types.variableDeclaration(isRepeated ? "const" : "let", [
    _compiler.types.variableDeclarator(
    identifier,
    isRepeated ? _compiler.types.arrayExpression([]) : _compiler.types.nullLiteral())]));



    parentPath.pushContainer(
    "attributes",
    _compiler.types.markoAttribute(targetProperty, identifier));

  }

  if (isRepeated) {
    path.replaceWith(
    (0, _withPreviousLocation.default)(
    _compiler.types.expressionStatement(
    _compiler.types.callExpression(
    _compiler.types.memberExpression(identifier, _compiler.types.identifier("push")),
    [(0, _util.getAttrs)(path)])),


    node));


  } else {
    path.replaceWith(
    (0, _withPreviousLocation.default)(
    _compiler.types.expressionStatement(
    _compiler.types.assignmentExpression("=", identifier, (0, _util.getAttrs)(path))),

    node));


  }
}

function isAttributeTagChild(tag) {
  if ((0, _babelUtils.isAttributeTag)(tag)) {
    return true;
  }

  if ((0, _babelUtils.isTransparentTag)(tag)) {
    const body = tag.get("body").get("body");
    return isAttributeTagChild(body[body.length - 1]);
  }

  return false;
}
//# sourceMappingURL=attribute-tag.js.map
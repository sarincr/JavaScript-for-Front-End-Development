{"version":3,"sources":["../../src/tag/custom-tag.js"],"names":["path","isNullable","hub","file","node","markoOpts","name","key","tagIdentifier","t","isStringLiteral","tagName","value","relativePath","extra","tagDef","taglibId","renderer","ignoreUnrecognizedTags","get","buildCodeFrameError","foundAttrs","customTagRenderCall","expressionStatement","callExpression","isNullLiteral","objectExpression","identifier","_componentDefIdentifier","renderBodyIdentifier","renderBodyProp","isObjectExpression","properties","find","prop","scope","generateUidIdentifier","insertBefore","variableDeclaration","variableDeclarator","replaceWith","ifStatement"],"mappings":"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","sourcesContent":["import { types as t } from \"@marko/compiler\";\nimport {\n  assertNoArgs,\n  getTagDef,\n  importDefault,\n  resolveRelativePath\n} from \"@marko/babel-utils\";\nimport { getAttrs, buildEventHandlerArray } from \"./util\";\nimport nativeTag from \"./native-tag\";\nimport withPreviousLocation from \"../util/with-previous-location\";\n\nexport default function (path, isNullable) {\n  const {\n    hub: { file },\n    node\n  } = path;\n  const { markoOpts } = file;\n  const { name, key } = node;\n\n  assertNoArgs(path);\n\n  let tagIdentifier;\n\n  if (t.isStringLiteral(name)) {\n    const tagName = name.value;\n    let relativePath = node.extra && node.extra.relativePath;\n\n    if (!relativePath) {\n      const tagDef = getTagDef(path);\n      if (\n        tagDef &&\n        tagDef.taglibId === \"marko-default-core\" &&\n        tagDef.renderer\n      ) {\n        // Normally new tags should not be added in the translate stage.\n        // We make an exception here for core tags, init-components & _preserve being the primary culprits.\n        // TODO: in the future refactor so this is not needed.\n        relativePath = resolveRelativePath(file, tagDef.renderer);\n      }\n    }\n\n    if (!relativePath) {\n      if (markoOpts.ignoreUnrecognizedTags) {\n        return nativeTag(path);\n      }\n\n      throw path\n        .get(\"name\")\n        .buildCodeFrameError(\n          `Unable to find entry point for custom tag <${tagName}>.`\n        );\n    }\n\n    tagIdentifier = importDefault(file, relativePath, tagName);\n  } else {\n    tagIdentifier = name;\n  }\n\n  const foundAttrs = getAttrs(path);\n  const customTagRenderCall = withPreviousLocation(\n    t.expressionStatement(\n      t.callExpression(\n        importDefault(\n          file,\n          \"marko/src/runtime/helpers/render-tag\",\n          \"marko_tag\"\n        ),\n        [\n          tagIdentifier,\n          // TODO: this could be left as null if we froze input mutations and used a default object in the runtime.\n          t.isNullLiteral(foundAttrs) ? t.objectExpression([]) : foundAttrs,\n          t.identifier(\"out\"),\n          file._componentDefIdentifier,\n          key,\n          ...buildEventHandlerArray(path)\n        ]\n      )\n    ),\n    node\n  );\n\n  if (isNullable) {\n    let renderBodyIdentifier;\n    const renderBodyProp =\n      t.isObjectExpression(foundAttrs) &&\n      foundAttrs.properties.find(\n        prop => prop.key && prop.key.value === \"renderBody\"\n      );\n\n    if (renderBodyProp) {\n      renderBodyIdentifier = path.scope.generateUidIdentifier(\"renderBody\");\n      path.insertBefore(\n        t.variableDeclaration(\"const\", [\n          t.variableDeclarator(renderBodyIdentifier, renderBodyProp.value)\n        ])\n      );\n\n      renderBodyProp.value = renderBodyIdentifier;\n    }\n\n    path.replaceWith(\n      t.ifStatement(\n        name,\n        customTagRenderCall,\n        renderBodyIdentifier &&\n          t.expressionStatement(\n            t.callExpression(renderBodyIdentifier, [t.identifier(\"out\")])\n          )\n      )\n    );\n  } else {\n    path.replaceWith(customTagRenderCall);\n  }\n}\n"],"file":"custom-tag.js"}
"use strict";exports.__esModule = true;exports.getAttrs = getAttrs;exports.buildEventHandlerArray = buildEventHandlerArray;exports.evaluateAttr = evaluateAttr;var _compiler = require("@marko/compiler");
var _babelUtils = require("@marko/babel-utils");

function getAttrs(path, preserveNames, skipRenderBody) {
  const { node } = path;
  const {
    attributes,
    body: { body, params },
    hasDynamicAttrTags } =
  node;
  const attrsLen = attributes.length;
  const childLen = body.length;
  const properties = [];
  const targetObjects = {};
  const tagDef = (0, _babelUtils.getTagDef)(path);
  const foundProperties = {};

  for (let i = 0; i < attrsLen; i++) {
    const { name, value } = attributes[i];

    if (name) {
      const attrDef = tagDef && tagDef.getAttribute(name);
      let targetProperties = properties;
      let targetProperty = name;
      let preserveName = preserveNames;

      if (attrDef) {
        if (attrDef.targetProperty) {
          const key = attrDef.targetProperty;
          preserveName =
          attrDef.preserveName !== false && attrDef.removeDashes !== true;

          if (attrDef.dynamicAttribute) {
            let targetObject = targetObjects[key];

            if (!targetObject) {
              properties.push(
              _compiler.types.objectProperty(
              _compiler.types.stringLiteral(key),
              targetObject = targetObjects[key] = _compiler.types.objectExpression([])));


            }

            targetProperties = targetObject.properties;
          } else {
            targetProperty = key;
          }
        } else if (
        !preserveName && (
        attrDef.preserveName === true || attrDef.removeDashes === false))
        {
          preserveName = true;
        }
      }

      if (!preserveName) {
        targetProperty = camelCase(targetProperty);
      }

      foundProperties[targetProperty] = true;
      targetProperties.push(
      _compiler.types.objectProperty(_compiler.types.stringLiteral(targetProperty), value));

    } else {
      properties.push(_compiler.types.spreadElement(value));
    }
  }

  if (!skipRenderBody && childLen) {
    let endDynamicAttrTagsIndex = -1;

    if (hasDynamicAttrTags) {
      endDynamicAttrTagsIndex = findLastIndex(
      body,
      ({ value }) => value === "END_ATTRIBUTE_TAGS");

      path.
      insertBefore(body.slice(0, endDynamicAttrTagsIndex)).
      map((child) => child.skip());
    }

    if (!hasDynamicAttrTags || endDynamicAttrTagsIndex !== childLen - 1) {
      properties.push(
      _compiler.types.objectProperty(
      _compiler.types.stringLiteral("renderBody"),
      _compiler.types.arrowFunctionExpression(
      [_compiler.types.identifier("out"), ...params],
      _compiler.types.blockStatement(
      hasDynamicAttrTags ?
      body.slice(endDynamicAttrTagsIndex + 1) :
      body))));




    }
  }

  // Default parameters
  tagDef &&
  tagDef.forEachAttribute &&
  tagDef.forEachAttribute((attr) => {
    if (foundProperties[attr.name] || attr.dynamicAttribute) {
      return;
    }

    if (attr.defaultValue !== undefined) {
      properties.push(
      _compiler.types.objectProperty(
      _compiler.types.stringLiteral(attr.name),
      _compiler.types.stringLiteral(attr.defaultValue + "")));


    } else if (attr.required) {
      throw path.
      get("name").
      buildCodeFrameError(`The "${attr.name}" attribute is required.`);
    }
  });

  if (properties.length === 0) {
    return _compiler.types.nullLiteral();
  }

  if (properties.length === 1 && _compiler.types.isSpreadElement(properties[0])) {
    return properties[0].argument;
  }

  return _compiler.types.objectExpression(properties);
}

function buildEventHandlerArray(path) {
  const { handlers } = path.node;
  if (!handlers) {
    return [];
  }

  return [
  _compiler.types.arrayExpression(
  Object.entries(handlers).map(([eventName, { arguments: args, once }]) => {
    const parts = [
    _compiler.types.stringLiteral(eventName),
    args[0],
    _compiler.types.booleanLiteral(once)];


    if (args.length > 1) {
      parts.push(_compiler.types.arrayExpression(args.slice(1)));
    }

    return _compiler.types.arrayExpression(parts);
  }))];


}

function evaluateAttr(attr) {
  const name = attr.get("name").node;
  const value = attr.get("value");
  let confident = false;
  let computed = undefined;

  if (name) {
    if (value.isRegExpLiteral()) {
      confident = true;
      computed = value.get("pattern").node;
    } else {
      const evaluated = value.evaluate();
      ({ confident, value: computed } = evaluated);

      if (computed === true) {
        computed = "";
      } else if (computed != null && computed !== false) {
        computed = computed + "";
      }
    }
  }

  return {
    confident,
    computed };

}

function camelCase(string) {
  return string.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}

function findLastIndex(arr, check) {
  for (let i = arr.length; i--;) {
    if (check(arr[i])) {
      return i;
    }
  }
}
//# sourceMappingURL=util.js.map
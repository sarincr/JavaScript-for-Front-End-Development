{"version":3,"sources":["../../src/tag/index.js"],"names":["enter","path","tagDef","translator","node","hook","t","attr","get","isMarkoAttribute","attributeTranslators","hub","file","markoOpts","ignoreUnrecognizedTags","forEach","child","set","stringLiteral","slice","resolveKey","exit","isUnknownDynamic","isDynamicNullable","name","types","findDynamicTagTypes","string","component","isIdentifier","tagIdentifier","scope","generateUidIdentifier","insertBefore","variableDeclaration","variableDeclarator","replaceWith","empty","_isDynamicString","HANDLE_BINDINGS","root","pending","pop","type","push","binding","getBinding","includes","kind","importSourcePath","parentPath","isStringLiteral","isMarkoFile","initialValue","assignments","constantViolations","length","assignment","operator","request","nodePath","extname","test"],"mappings":"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","sourcesContent":["import nodePath from \"path\";\nimport { types as t } from \"@marko/compiler\";\nimport {\n  getTagDef,\n  isDynamicTag,\n  isAttributeTag,\n  isMacroTag,\n  isNativeTag,\n  findAttributeTags,\n  assertNoVar\n} from \"@marko/babel-utils\";\nimport nativeTag from \"./native-tag\";\nimport dynamicTag from \"./dynamic-tag\";\nimport attributeTag from \"./attribute-tag\";\nimport customTag from \"./custom-tag\";\nimport macroTag from \"./macro-tag\";\nimport attributeTranslators from \"./attribute\";\nimport { getKeyManager } from \"../util/key-manager\";\nimport { enter, exit } from \"../util/plugin-hooks\";\nimport { optimizeStaticVDOM } from \"../util/optimize-vdom-create\";\n\nexport default {\n  enter(path) {\n    const tagDef = getTagDef(path);\n\n    if (tagDef && tagDef.translator) {\n      const { node } = path;\n      enter(tagDef.translator.hook, path, t);\n\n      if (path.node !== node) {\n        return;\n      }\n    }\n\n    assertNoVar(path);\n\n    for (const attr of path.get(\"attributes\")) {\n      if (attr.isMarkoAttribute()) {\n        const { node } = path;\n        attributeTranslators.enter(attr);\n        if (path.node !== node) {\n          return;\n        }\n      }\n    }\n\n    if (path.hub.file.markoOpts.ignoreUnrecognizedTags && !tagDef) {\n      findAttributeTags(path).forEach(child => {\n        child.set(\n          \"name\",\n          t.stringLiteral(`at_${child.get(\"name.value\").node.slice(1)}`)\n        );\n      });\n    }\n\n    if (!isAttributeTag(path)) {\n      getKeyManager(path).resolveKey(path);\n    }\n\n    optimizeStaticVDOM(path);\n  },\n  exit(path) {\n    let isUnknownDynamic = false;\n    let isDynamicNullable = false;\n\n    if (isDynamicTag(path)) {\n      const name = path.get(\"name\");\n      const types = findDynamicTagTypes(name);\n      if (types && !(types.string && types.component)) {\n        if (!name.isIdentifier()) {\n          const tagIdentifier = path.scope.generateUidIdentifier(`tagName`);\n          path.insertBefore(\n            t.variableDeclaration(\"const\", [\n              t.variableDeclarator(tagIdentifier, name.node)\n            ])\n          );\n\n          name.replaceWith(tagIdentifier);\n        }\n\n        isDynamicNullable = types.empty;\n        path.node._isDynamicString = types.string;\n      } else {\n        isUnknownDynamic = true;\n      }\n    }\n\n    for (const attr of path.get(\"attributes\")) {\n      if (attr.isMarkoAttribute()) {\n        const { node } = path;\n        attributeTranslators.exit(attr);\n        if (path.node !== node) {\n          return;\n        }\n      }\n    }\n\n    if (isUnknownDynamic) {\n      return dynamicTag(path);\n    }\n\n    if (isAttributeTag(path)) {\n      return attributeTag(path);\n    }\n\n    if (isMacroTag(path)) {\n      return macroTag(path);\n    }\n\n    const tagDef = getTagDef(path);\n\n    if (tagDef && tagDef.translator) {\n      const { node } = path;\n\n      exit(tagDef.translator.hook, path, t);\n\n      if (path.node !== node) {\n        return;\n      }\n    }\n\n    if (isNativeTag(path)) {\n      return nativeTag(path, isDynamicNullable);\n    } else {\n      return customTag(path, isDynamicNullable);\n    }\n  }\n};\n\nconst HANDLE_BINDINGS = [\"module\", \"var\", \"let\", \"const\"];\nfunction findDynamicTagTypes(root) {\n  const pending = [root];\n  const types = {\n    string: false,\n    empty: false,\n    component: false\n  };\n\n  let path;\n  while ((path = pending.pop())) {\n    switch (path.type) {\n      case \"ConditionalExpression\":\n        pending.push(path.get(\"consequent\"));\n\n        if (path.get(\"alternate\").node) {\n          pending.push(path.get(\"alternate\"));\n        }\n        break;\n\n      case \"LogicalExpression\":\n        if (path.get(\"operator\").node === \"||\") {\n          pending.push(path.get(\"left\"));\n        } else {\n          types.empty = true;\n        }\n\n        pending.push(path.get(\"right\"));\n        break;\n\n      case \"AssignmentExpression\":\n        pending.push(path.get(\"right\"));\n        break;\n\n      case \"BinaryExpression\":\n        if (path.get(\"operator\").node !== \"+\") {\n          return false;\n        }\n\n        types.string = true;\n        break;\n\n      case \"StringLiteral\":\n      case \"TemplateLiteral\":\n        types.string = true;\n        break;\n\n      case \"NullLiteral\":\n        types.empty = true;\n        break;\n\n      case \"Identifier\":\n        if (path.get(\"name\").node === \"undefined\") {\n          types.empty = true;\n        } else {\n          const binding = path.scope.getBinding(path.node.name);\n\n          if (!binding || !HANDLE_BINDINGS.includes(binding.kind)) {\n            return false;\n          }\n\n          if (binding.kind === \"module\") {\n            const importSourcePath = binding.path.parentPath.get(\"source\");\n            if (\n              importSourcePath.isStringLiteral() &&\n              isMarkoFile(importSourcePath.get(\"value\").node)\n            ) {\n              types.component = true;\n            } else {\n              return false;\n            }\n          } else {\n            const initialValue = binding.path.get(\"init\");\n            if (initialValue.node) {\n              pending.push(initialValue);\n            } else {\n              types.empty = true;\n            }\n\n            const assignments = binding.constantViolations;\n            if (assignments && assignments.length) {\n              for (const assignment of assignments) {\n                const operator = assignment.get(\"operator\").node;\n                if (operator === \"=\") {\n                  pending.push(assignment.get(\"right\"));\n                } else if (operator === \"+=\") {\n                  types.string = true;\n                } else {\n                  return false;\n                }\n              }\n            }\n          }\n        }\n        break;\n\n      default:\n        return false;\n    }\n  }\n\n  return types;\n}\n\nfunction isMarkoFile(request) {\n  return nodePath.extname(request) === \".marko\" || /^<.*>$/.test(request);\n}\n"],"file":"index.js"}
"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.default = getComponentFiles;var _path = _interopRequireDefault(require("path"));
var _escapeStringRegexp = _interopRequireDefault(require("escape-string-regexp"));

const COMPONENT_FILES_KEY = Symbol();

function getComponentFiles({ hub: { file } }) {
  const meta = file.metadata.marko;

  if (meta[COMPONENT_FILES_KEY]) {
    return meta[COMPONENT_FILES_KEY];
  }

  const { filename } = file.opts;
  const fs = file.markoOpts.fileSystem;
  const ext = _path.default.extname(filename);
  const dirname = _path.default.dirname(filename);
  const dirFiles = fs.readdirSync(dirname).sort();
  const nameNoExt = _path.default.basename(filename, ext);
  const isEntry = "index" === nameNoExt;
  const fileMatch = `(${(0, _escapeStringRegexp.default)(nameNoExt)}\\.${isEntry ? "|" : ""})`;
  const styleMatch = new RegExp(`^${fileMatch}style\\.\\w+$`);
  const componentMatch = new RegExp(`^${fileMatch}component\\.\\w+$`);
  const splitComponentMatch = new RegExp(
  `^${fileMatch}component-browser\\.\\w+$`);

  const packageMatch = new RegExp(`^${fileMatch}browser\\.\\json$`);
  let styleFile;
  let packageFile;
  let componentFile;
  let componentBrowserFile;

  for (const file of dirFiles) {
    if (!styleFile && styleMatch.test(file)) {
      styleFile = `./${file}`;
    } else if (!packageFile && packageMatch.test(file)) {
      packageFile = `./${file}`;
    } else if (!componentFile && componentMatch.test(file)) {
      componentFile = `./${file}`;
      meta.hasComponent = true;
    } else if (!componentBrowserFile && splitComponentMatch.test(file)) {
      componentBrowserFile = `./${file}`;
      meta.hasComponentBrowser = true;
    }
  }

  return meta[COMPONENT_FILES_KEY] = {
    styleFile,
    packageFile,
    componentFile,
    componentBrowserFile };

}
//# sourceMappingURL=get-component-files.js.map
"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.default = void 0;var _path = _interopRequireDefault(require("path"));
var _magicString = _interopRequireDefault(require("magic-string"));
var _compiler = require("@marko/compiler");
var _babelUtils = require("@marko/babel-utils");var _default =

(entryFile, isHydrate) => {
  const { modules, resolveVirtualDependency, hydrateIncludeImports } =
  entryFile.markoOpts;
  const hydratedFiles = new Set();
  const program = entryFile.path;
  const shouldIncludeImport = toTestFn(hydrateIncludeImports);

  if (!isHydrate) {
    addBrowserDeps(entryFile);
    return;
  }

  const registerId = _compiler.types.identifier("register");
  const watchFiles = new Set();
  let hasComponents = false;
  let splitComponentIndex = 0;
  program.set("body", []);
  program.skip();

  addHydrateDeps(entryFile);
  entryFile.metadata.marko.watchFiles = Array.from(watchFiles);

  if (hasComponents) {
    const initId = _compiler.types.identifier("init");
    const markoComponentsImport = importPath(
    resolvePath(entryFile, "marko/src/runtime/components"));

    if (splitComponentIndex) {
      markoComponentsImport.specifiers.push(
      _compiler.types.importSpecifier(registerId, registerId));

    }
    markoComponentsImport.specifiers.push(_compiler.types.importSpecifier(initId, initId));
    program.unshiftContainer("body", markoComponentsImport);
    program.pushContainer(
    "body",
    _compiler.types.expressionStatement(
    _compiler.types.callExpression(
    initId,
    entryFile.markoOpts.runtimeId ?
    [_compiler.types.stringLiteral(entryFile.markoOpts.runtimeId)] :
    [])));



  }

  function addHydrateDeps(file) {
    const meta = file.metadata.marko;
    const resolved = (0, _babelUtils.resolveRelativePath)(entryFile, file.opts.filename);
    if (hydratedFiles.has(resolved)) return;

    hydratedFiles.add(resolved);

    if (meta.component) {
      hasComponents = true;

      if (_path.default.basename(meta.component) === _path.default.basename(file.opts.filename)) {
        // Stateful component.
        program.pushContainer("body", importPath(resolved));
        return;
      }
    }

    watchFiles.add(file.opts.filename);

    for (const watchFile of meta.watchFiles) {
      watchFiles.add(watchFile);
    }

    addBrowserDeps(file);

    for (const imported of meta.imports) {
      if (shouldIncludeImport(imported)) {
        program.pushContainer("body", importPath(resolvePath(file, imported)));
      }
    }

    for (const tag of meta.tags) {
      if (tag.endsWith(".marko")) {
        if (!hydratedFiles.has(resolvePath(file, tag))) {
          addHydrateDeps((0, _babelUtils.loadFileForImport)(file, tag));
        }
      }
    }

    if (meta.component) {
      // Split component
      const splitComponentId = _compiler.types.identifier(
      `component_${splitComponentIndex++}`);

      const splitComponentImport = importPath(
      resolvePath(file, meta.component));

      splitComponentImport.specifiers.push(
      _compiler.types.importDefaultSpecifier(splitComponentId));

      program.pushContainer("body", splitComponentImport);
      program.pushContainer(
      "body",
      _compiler.types.expressionStatement(
      _compiler.types.callExpression(registerId, [
      _compiler.types.stringLiteral(meta.id),
      splitComponentId])));



    }
  }

  function addBrowserDeps(file) {
    const { filename, sourceMaps } = file.opts;
    let s;

    for (let dep of file.metadata.marko.deps) {
      if (typeof dep !== "string") {
        const { virtualPath } = dep;
        let { code } = dep;
        let map;

        if (sourceMaps && dep.startPos !== undefined) {
          s = s || new _magicString.default(file.code, { source: filename });
          map = s.snip(dep.startPos, dep.endPos).generateMap({
            source: filename,
            includeContent: true });


          if (sourceMaps === "inline" || sourceMaps === "both") {
            code += dep.style ?
            `\n/*# sourceMappingURL=${map.toUrl()}*/` :
            `\n//# sourceMappingURL=${map.toUrl()}`;

            if (sourceMaps === "inline") {
              map = undefined;
            }
          }
        }

        dep = resolveVirtualDependency(filename, {
          map,
          code,
          virtualPath });

      } else if (dep.startsWith("package:")) {
        continue;
      }

      program.pushContainer("body", importPath(resolvePath(file, dep)));
    }
  }

  function resolvePath(file, req) {
    return file === entryFile ?
    (0, _babelUtils.resolveRelativePath)(file, req) :
    (0, _babelUtils.resolveRelativePath)(
    entryFile,
    _path.default.join(file.opts.filename, "..", req));

  }

  function importPath(path) {
    if (modules === "cjs") {
      return _compiler.types.expressionStatement(
      _compiler.types.callExpression(_compiler.types.identifier("require"), [_compiler.types.stringLiteral(path)]));

    }

    return _compiler.types.importDeclaration([], _compiler.types.stringLiteral(path));
  }
};exports.default = _default;

function toTestFn(val) {
  if (typeof val === "function") {
    return val;
  }

  return val.test.bind(val);
}
//# sourceMappingURL=add-dependencies.js.map
"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.default = _default;var _compiler = require("@marko/compiler");
var _babelUtils = require("@marko/babel-utils");
var _getComponentFiles = _interopRequireDefault(require("../../util/get-component-files"));

function _default(path) {
  const {
    node,
    hub: { file } } =
  path;
  const {
    rawValue: code,
    name: { start } } =
  node;
  const meta = file.metadata.marko;

  if ((0, _getComponentFiles.default)(path).componentFile) {
    throw path.
    get("name").
    buildCodeFrameError(
    'A Marko file can either have an inline class, or an external "component.js", but not both.');

  }

  if (meta.hasComponent) {
    throw path.
    get("name").
    buildCodeFrameError(
    "A Marko component can only have one top level class.");

  }

  const parsed = (0, _babelUtils.parseExpression)(file, code, start);

  if (parsed.id) {
    throw file.buildCodeFrameError(
    parsed.id,
    "Component class cannot have a name.");

  }

  if (parsed.superClass) {
    throw file.buildCodeFrameError(
    parsed.superClass,
    "Component class cannot have a super class.");

  }

  const constructorProp = parsed.body.body.find(
  (prop) => _compiler.types.isClassMethod(prop) && prop.kind === "constructor");

  if (constructorProp) {
    throw file.buildCodeFrameError(
    constructorProp.key,
    "The constructor method should not be used for a component, use onCreate instead.");

  }

  meta.hasComponent = true;
  path.replaceWith(_compiler.types.markoClass(parsed.body));
}
//# sourceMappingURL=parse-class.js.map
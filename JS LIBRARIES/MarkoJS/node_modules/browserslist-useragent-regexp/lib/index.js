'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var regexps = require('useragent/lib/regexps');
var browserslist = require('browserslist');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var regexps__default = /*#__PURE__*/_interopDefaultLegacy(regexps);
var browserslist__default = /*#__PURE__*/_interopDefaultLegacy(browserslist);

exports.BrowserRegExpSourceProp = void 0;

(function (BrowserRegExpSourceProp) {
  BrowserRegExpSourceProp[BrowserRegExpSourceProp["RegExp"] = 0] = "RegExp";
  BrowserRegExpSourceProp[BrowserRegExpSourceProp["Family"] = 1] = "Family";
  BrowserRegExpSourceProp[BrowserRegExpSourceProp["Major"] = 2] = "Major";
  BrowserRegExpSourceProp[BrowserRegExpSourceProp["Minor"] = 3] = "Minor";
  BrowserRegExpSourceProp[BrowserRegExpSourceProp["Patch"] = 4] = "Patch";
})(exports.BrowserRegExpSourceProp || (exports.BrowserRegExpSourceProp = {}));

const DIGIT_PATTERN = '\\d';
const NUMBER_PATTERN = `${DIGIT_PATTERN}+`;
const BRACED_NUMBER_PATTERN = `(${NUMBER_PATTERN})`;
const ESCAPE_SYMBOL = '\\';
/**
 * Join RegExp parts with "or".
 * @param parts - Some RegExp parts.
 * @param wrapRequired - Should always wrap with braces.
 * @returns Joined parts.
 */

function joinParts(parts, wrapRequired = false) {
  const joined = parts.join('|');
  return wrapRequired || parts.length > 1 ? `(${joined})` : joined;
}
/**
 * Join RegExps with "or".
 * @param versionedBrowsersRegExps - RegExps strings array.
 * @returns Joined RegExps string.
 */

function joinVersionedBrowsersRegExps(versionedBrowsersRegExps) {
  return versionedBrowsersRegExps.map(_ => `(${_.regExpString})`).join('|');
}
/**
 * Contains number pattern or not.
 * @param regExp - Target string or RegExp.
 * @returns Has or not.
 */

function hasNumberPattern(regExp) {
  return regExp.toString().includes(BRACED_NUMBER_PATTERN);
}
/**
 * Find number patterns count.
 * @param regExp - Target string or RegExp.
 * @returns Number patterns count.
 */

function getNumberPatternsCount(regExp) {
  return regExp.toString().split(BRACED_NUMBER_PATTERN).length - 1;
}
/**
 * Convert RegExp to string without slashes.
 * @param regExp - Target RegExp.
 * @returns RegExp string without slashes.
 */

function regExpToString(regExp) {
  return regExp.toString().replace(/^\/|\/$/g, '');
}
/**
 * Replace number patterns.
 * @param regExp - Target RegExp.
 * @param numbers - Number patterns to paste.
 * @param numberPatternsCount - Number patterns count to replace.
 * @returns RegExp string with replaced number patterns.
 */

function replaceNumberPatterns(regExp, numbers, numberPatternsCount) {
  const strRegExp = typeof regExp === 'string' ? regExp : regExpToString(regExp);
  const numbersToReplace = typeof numberPatternsCount === 'number' && numberPatternsCount < numbers.length ? numbers.slice(0, numberPatternsCount) : numbers;
  const numberedStrRegExp = numbersToReplace.reduce((_, num) => _.replace(BRACED_NUMBER_PATTERN, num), strRegExp);
  return numberedStrRegExp;
}
/**
 * Transform number to digits array.
 * @param num - Target number.
 * @returns Digits array.
 */

function numberToDigits(num) {
  return Array.from(num.toString()).map(Number);
}
/**
 * Skip every char inside square braces.
 * @param skip - Current skip state.
 * @param prevChar - Previous char.
 * @param char - Current char to check.
 * @returns Should skip this char or not.
 */

function skipSquareBraces(skip, prevChar, char) {
  if (char === '[' && prevChar !== ESCAPE_SYMBOL) {
    return true;
  }

  if (char === ']' && prevChar !== ESCAPE_SYMBOL) {
    return false;
  }

  return skip;
}
/**
 * Get possible RegExp group postfix.
 * @param regExpStr - Whole RegExp string.
 * @param startFrom - Index to start capture.
 * @returns RegExp group postfix part.
 */

function capturePostfix(regExpStr, startFrom) {
  let char = regExpStr[startFrom];

  switch (char) {
    case '+':
    case '*':
    case '?':
      return char;

    case '(':
      {
        const nextChar = regExpStr[startFrom + 1];
        const afterNextChar = regExpStr[startFrom + 2];

        if (nextChar !== '?' || afterNextChar !== '=' && afterNextChar !== '!') {
          return '';
        }

        break;
      }

    case '{':
      break;

    default:
      return '';
  }

  const regExpStrLength = regExpStr.length;
  let prevChar = '';
  let braceBalance = 0;
  let skip = false;
  let postfix = '';

  for (let i = startFrom; i < regExpStrLength; i++) {
    char = regExpStr[i];
    prevChar = regExpStr[i - 1];
    skip = skipSquareBraces(skip, prevChar, char);

    if (!skip && prevChar !== ESCAPE_SYMBOL && (char === '(' || char === '{')) {
      braceBalance++;
    }

    if (braceBalance > 0) {
      postfix += char;
    }

    if (!skip && prevChar !== ESCAPE_SYMBOL && braceBalance > 0 && (char === ')' || char === '}')) {
      braceBalance--;

      if (braceBalance === 0) {
        break;
      }
    }
  }

  return postfix;
}

exports.SemverPart = void 0;

(function (SemverPart) {
  SemverPart[SemverPart["Major"] = 0] = "Major";
  SemverPart[SemverPart["Minor"] = 1] = "Minor";
  SemverPart[SemverPart["Patch"] = 2] = "Patch";
})(exports.SemverPart || (exports.SemverPart = {}));

/* eslint-disable @typescript-eslint/naming-convention */
const BROWSERS_SHIRTNAMES = {
  bb: 'BlackBerry',
  and_chr: 'Chrome',
  ChromeAndroid: 'Chrome',
  FirefoxAndroid: 'Firefox',
  ff: 'Firefox',
  ie_mob: 'ExplorerMobile',
  ie: 'Explorer',
  and_ff: 'Firefox',
  ios_saf: 'iOS',
  op_mini: 'OperaMini',
  op_mob: 'OperaMobile',
  and_qq: 'QQAndroid',
  and_uc: 'UCAndroid'
};
const BROWSERS_SHIRTNAMES_REGEXP = new RegExp(`(${Object.keys(BROWSERS_SHIRTNAMES).join('|')})`);

/**
 * Replace family shirtname with fullname.
 * @param query - String with shirtname.
 * @returns String with fullname.
 */

function normalizeBrowserFamily(query) {
  const matches = BROWSERS_SHIRTNAMES_REGEXP.exec(query);

  if (Array.isArray(matches)) {
    const [shirtname] = matches;
    return query.replace(shirtname, BROWSERS_SHIRTNAMES[shirtname]);
  }

  return query;
}
/**
 * Compare two arrays.
 * @param a - Array to compare.
 * @param b - Array to compare.
 * @param from - Index to start compare from.
 * @returns Equals or not.
 */

function compareArrays(a, b, from = 0) {
  const len = a.length;

  for (let i = from; i < len; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
}
/**
 * Array of numbers to array of first and last elements.
 * @param numbers - Array of numbers.
 * @returns Number or two numbers.
 */

function numbersToRanges(numbers) {
  if (typeof numbers === 'number') {
    return numbers;
  }

  if (numbers.length === 1) {
    return numbers[0];
  }

  return [numbers[0], numbers[numbers.length - 1]];
}

/**
 * Check target if is 'all'.
 * @param version - Target to check.
 * @returns Is 'all' or not.
 */

function isAllVersion(version) {
  const target = Array.isArray(version) ? version[0] : version;
  return target === 'all';
}
/**
 * Remove duplicated arrays.
 * @param items - Array of arrays to remove duplicates.
 * @returns Uniq arrays.
 */

function uniqItems(items) {
  return items.filter(Boolean).filter((a, i, items) => items && !items.some((b, j) => j > i && compareArrays(a, b)));
}

/**
 * Get digit pattern.
 * @param digit - Ray start.
 * @param includes - Include start digit or use next.
 * @returns Digit pattern.
 */

function rayRangeDigitPattern(digit, includes) {
  const rangeStart = digit + Number(!includes);

  if (rangeStart === 0) {
    return DIGIT_PATTERN;
  }

  if (rangeStart === 9) {
    return '9';
  }

  if (rangeStart > 9) {
    return '';
  }

  return `[${rangeStart}-9]`;
}

function filterDigitPattern(pattern) {
  return pattern === DIGIT_PATTERN;
}
/**
 * Reduce number patterns by removing useless patterns.
 * @todo   Is it still useful?
 * @param raysNumberPatterns - Number patterns to filter.
 * @returns Optimized number patterns.
 */


function optimizeRaysNumberPatterns(raysNumberPatterns) {
  let prev = [];
  let partsCount = 0;
  let prevPartsCount = 0;
  return raysNumberPatterns.filter((digitsPatterns, i) => {
    if (i > 0) {
      partsCount = digitsPatterns.filter(filterDigitPattern).length;
      prevPartsCount = prev.filter(filterDigitPattern).length;

      if (partsCount <= prevPartsCount) {
        return false;
      }
    }

    prev = digitsPatterns;
    return true;
  });
}
/**
 * Create numeric ray pattern.
 * @param from - Start from this number.
 * @returns Numeric ray pattern parts.
 */

function rayToNumberPatterns(from) {
  if (from === 0) {
    return [NUMBER_PATTERN];
  }

  const digits = numberToDigits(from);
  const digitsCount = digits.length;
  const other = `${DIGIT_PATTERN}{${digitsCount + 1},}`;
  const zeros = digitsCount - 1;

  if (from / Math.pow(10, zeros) === digits[0]) {
    return [`${rayRangeDigitPattern(digits[0], true)}${DIGIT_PATTERN.repeat(zeros)}`, other];
  }

  const raysNumberPatterns = optimizeRaysNumberPatterns(digits.map((_, i) => {
    const ri = digitsCount - i - 1;
    const d = i <= 0;
    let prev = ' ';
    return digits.map((digit, j) => {
      if (j < ri) {
        return digit.toString();
      }

      if (!prev) {
        return '';
      }

      if (j > ri) {
        return DIGIT_PATTERN;
      }

      prev = rayRangeDigitPattern(digit, d);
      return prev;
    });
  }));
  const numberPatterns = raysNumberPatterns.map(_ => _.join(''));
  numberPatterns.push(other);
  return numberPatterns;
}

/**
 * Get digit pattern.
 * @param from - Segment start.
 * @param to - Segment end.
 * @param zeros - Zeros to add as prefix.
 * @returns Digit pattern.
 */

function segmentRangeNumberPattern(from, to, zeros) {
  if (to < from) {
    return '';
  }

  const zerosPrefix = typeof zeros === 'number' && zeros > 0 ? '0'.repeat(zeros) : '';

  if (from === to) {
    return `${zerosPrefix}${from}`;
  }

  if (from === 0 && to === 9) {
    return `${zerosPrefix}${DIGIT_PATTERN}`;
  }

  return `${zerosPrefix}[${from}-${to}]`;
}
/**
 * Split segment range to decade ranges.
 * @param from - Segment start.
 * @param to - Segment end.
 * @returns Ranges.
 */

function splitToDecadeRanges(from, to) {
  const ranges = [];
  let num = from;
  let decade = 1;

  do {
    decade *= 10;

    if (num < decade) {
      ranges.push([num, Math.min(decade - 1, to)]);
      num = decade;
    }
  } while (decade <= to);

  return ranges;
}
/**
 * Get common and diffs of two numbers (arrays of digits).
 * @param a - Digits.
 * @param b - Other digits.
 * @returns Common part and diffs.
 */

function splitCommonDiff(a, b) {
  const len = a.length;

  if (len !== b.length || a[0] !== b[0]) {
    return null;
  }

  let common = a[0].toString();
  let currA = 0;
  let currB = 0;
  let diffA = '';
  let diffB = '';

  for (let i = 1; i < len; i++) {
    currA = a[i];
    currB = b[i];

    if (currA === currB) {
      common += currA;
    } else {
      diffA += currA;
      diffB += currB;
    }
  }

  return [common, parseInt(diffA, 10), parseInt(diffB, 10)];
}
/**
 * Get shirter variant.
 * @param from - Segment start.
 * @param to - Segment end.
 * @param rangeNumberPatterns - Numeric segment patterns.
 * @returns Enum or numeric segment patterns.
 */

function enumOrRange(from, to, rangeNumberPatterns) {
  const rangePartsCount = rangeNumberPatterns.length;
  const nums = [];
  let rangeIndex = 0;
  let rangeSymbolsCount = 0;
  let enumSymbolsCount = 0;

  for (let num = from; num <= to; num++) {
    nums.push(num.toString());
    enumSymbolsCount += Math.floor(Math.log10(num) + 1) + 1;

    while (enumSymbolsCount > rangeSymbolsCount) {
      if (rangeIndex >= rangePartsCount) {
        return rangeNumberPatterns;
      }

      rangeSymbolsCount += rangeNumberPatterns[rangeIndex++].length + 1;
    }
  }

  return nums;
}
/**
 * Get segment patterns.
 * @todo   Optomize. E.g. 32-99.
 * @param from - Segment start.
 * @param to - Segment end.
 * @param digitsInNumber - How many digits should be en number. Will be filled by zeros.
 * @returns Segment patterns.
 */

function segmentToNumberPatterns(from, to, digitsInNumber = 0) {
  const fromDigits = numberToDigits(from);
  const digitsCount = fromDigits.length;

  if (from < 10 && to < 10 || from === to) {
    const zeros = digitsInNumber - digitsCount;
    return [segmentRangeNumberPattern(from, to, zeros)];
  }

  const toDigits = numberToDigits(to);

  if (digitsCount !== toDigits.length) {
    const decadeRanges = splitToDecadeRanges(from, to);
    const parts = [].concat(...decadeRanges.map(([from, to]) => segmentToNumberPatterns(from, to, digitsInNumber)));
    return parts;
  }

  const commonStart = splitCommonDiff(fromDigits, toDigits);

  if (Array.isArray(commonStart)) {
    const [common, from, to] = commonStart;
    const digitsInNumber = digitsCount - common.length;
    const diffParts = segmentToNumberPatterns(from, to, digitsInNumber);
    return [`${common}${joinParts(diffParts)}`];
  }

  const range = Array.from({
    length: digitsCount - 1
  });
  const middleSegment = segmentRangeNumberPattern(fromDigits[0] + 1, toDigits[0] - 1);
  const parts = [...range.map((_, i) => {
    const ri = digitsCount - i - 1;
    const d = Number(i > 0);
    return fromDigits.map((digit, j) => {
      if (j < ri) {
        return digit;
      }

      if (j > ri) {
        return segmentRangeNumberPattern(0, 9);
      }

      return segmentRangeNumberPattern(digit + d, 9);
    }).join('');
  }), // but output more readable
  ...(middleSegment ? [`${middleSegment}${DIGIT_PATTERN.repeat(digitsCount - 1)}`] : []), ...range.map((_, i) => {
    const ri = digitsCount - i - 1;
    const d = Number(i > 0);
    return toDigits.map((digit, j) => {
      if (j < ri) {
        return digit;
      }

      if (j > ri) {
        return segmentRangeNumberPattern(0, 9);
      }

      return segmentRangeNumberPattern(0, digit - d);
    }).join('');
  })];
  return parts;
}
/**
 * Get segment or enum patterns.
 * @param from - Segment start.
 * @param to - Segment end.
 * @returns Enum or numeric segment patterns.
 */

function segmentToNumberPatternsOrEnum(from, to) {
  return enumOrRange(from, to, segmentToNumberPatterns(from, to));
}

/**
 * Get RegExp for given numeric range.
 * @param from - Range start.
 * @param to - Range end.
 * @returns Range pattern.
 */

function rangeToRegExp(from, to = Infinity) {
  if (isAllVersion(from)) {
    return NUMBER_PATTERN;
  }

  const numberPatterns = to === Infinity ? rayToNumberPatterns(from) : segmentToNumberPatternsOrEnum(from, to);
  const regExpStr = joinParts(numberPatterns);
  return regExpStr;
}

/**
 * Get semver from string or array.
 * @param version - Target to convert.
 * @returns Array with semver parts.
 */

function semverify(version) {
  const versionParts = Array.isArray(version) ? version : version.toString().split('.');

  if (isAllVersion(versionParts[0])) {
    return [versionParts[0], 0, 0];
  }

  let versionPart = null;
  let semverPart = null;
  const semver = [0, 0, 0];

  for (let i = 0; i < 3; i++) {
    versionPart = versionParts[i];

    if (typeof versionPart === 'undefined') {
      continue;
    }

    semverPart = typeof versionPart === 'number' ? versionPart : parseInt(versionPart, 10);

    if (isNaN(semverPart)) {
      return null;
    }

    semver[i] = semverPart;
  }

  return semver;
}
/**
 * Compare semvers.
 * @param a - Semver to compare.
 * @param b - Semver to compare with.
 * @param options - Compare options.
 * @returns Equals or not.
 */

function compareSemvers(a, b, options) {
  const [major, minor, patch] = a;
  const [majorBase, minorBase, patchBase] = b;
  const {
    ignoreMinor,
    ignorePatch,
    allowHigherVersions
  } = options;

  if (isAllVersion(majorBase)) {
    return true;
  }

  const compareMinor = !ignoreMinor; // const comparePatch = ignoreMinor ? false : !ignorePatch;

  const comparePatch = compareMinor && !ignorePatch;

  if (allowHigherVersions) {
    if (comparePatch && patch < patchBase || compareMinor && minor < minorBase) {
      return false;
    }

    return major >= majorBase;
  }

  if (comparePatch && patch !== patchBase || compareMinor && minor !== minorBase) {
    return false;
  }

  return major === majorBase;
}
/**
 * Get required semver parts count.
 * @param version - Semver parts or ranges.
 * @param options - Semver compare options.
 * @returns Required semver parts count.
 */

function getRequiredSemverPartsCount(version, options) {
  const {
    ignoreMinor,
    ignorePatch,
    allowZeroSubversions
  } = options;
  let shouldRepeatCount = ignoreMinor ? 1 : ignorePatch ? 2 : 3;

  if (allowZeroSubversions) {
    for (let i = shouldRepeatCount - 1; i > 0; i--) {
      if (version[i] !== 0 || shouldRepeatCount === 1) {
        break;
      }

      shouldRepeatCount--;
    }
  }

  return shouldRepeatCount;
}
/**
 * Ranged semver to regexp patterns.
 * @param rangedVersion - Ranged semver.
 * @param options - Semver compare options.
 * @returns Array of regexp pattern strings.
 */

function rangedSemverToRegExp(rangedVersion, options) {
  const {
    ignoreMinor,
    ignorePatch,
    allowHigherVersions
  } = options;
  const ignoreIndex = isAllVersion(rangedVersion[0]) ? 0 : ignoreMinor ? 1 : ignorePatch ? 2 : Infinity;

  if (allowHigherVersions) {
    const numberPatterns = uniqItems(rangedVersion.map((_, i) => {
      const ri = 2 - i;
      const d = Number(i > 0);
      let start = 0;
      return rangedVersion.map((range, j) => {
        if (j >= ignoreIndex) {
          return BRACED_NUMBER_PATTERN;
        }

        start = Array.isArray(range) ? range[0] : range;

        if (j < ri) {
          return start.toString();
        }

        if (j > ri) {
          return BRACED_NUMBER_PATTERN;
        }

        return rangeToRegExp(start + d);
      });
    }));
    return numberPatterns;
  }

  const numberPatterns = rangedVersion.map((range, i) => {
    if (i >= ignoreIndex) {
      return BRACED_NUMBER_PATTERN;
    }

    if (Array.isArray(range)) {
      return rangeToRegExp(range[0], range[1]);
    }

    return range.toString();
  });
  return [numberPatterns];
}

/**
 * Remove duplicates from array.
 * @param items - Items to filter.
 * @returns Uniq items.
 */

function uniq(items) {
  return items.filter((_, i) => !items.includes(_, i + 1));
}
/**
 * Check version.
 * @param minVersion - Semver version.
 * @param maxVersion - Semver version.
 * @param bases - Base semver versions.
 * @param options - Semver compare options.
 * @returns Some version is matched.
 */

function someSemverMatched(minVersion, maxVersion, bases, options) {
  const compareOptions = { ...options,
    allowHigherVersions: true
  };
  return (!minVersion || bases.some(_ => compareSemvers(_, minVersion, compareOptions))) && (!maxVersion || bases.some(_ => compareSemvers(maxVersion, _, compareOptions)));
}
/**
 * Another version check. ^.^
 * @param version - Semver version.
 * @param regExp - Useragent RegExp.
 * @returns Has version or not.
 */

function hasVersion(version, regExp) {
  return Boolean(version || hasNumberPattern(regExp));
}
/**
 * Check browser family.
 * @param exact - Compare exact or not.
 * @param family - Browser family.
 * @param searchFamilies  - Browser family variations.
 * @returns Family matched or not.
 */

function familyMatched(exact, family, searchFamilies) {
  const isRegExp = family instanceof RegExp;
  let matcher = null;

  switch (true) {
    case isRegExp:
      {
        const regExpString = family.toString();

        matcher = _ => new RegExp(`(^|[^\\w])${_.replace(/ /g, '\\s*')}([^\\w]|$)`).test(regExpString);

        break;
      }

    case exact:
      matcher = _ => _ === family;

      break;

    default:
      matcher = _ => family.includes(_);

  }

  return searchFamilies.some(matcher);
}

/**
 * Get browser min and max versions for given useragent RegExp.
 * @param regExp - Target RegExp.
 * @returns Min and max versions.
 */

function getMinMaxVersions(regExp) {
  const regExpString = regExpToString(regExp);
  /* istanbul ignore next */

  switch (true) {
    /**
     * https://developers.whatismybrowser.com/useragents/explore/software_name/fennec/
     */
    case regExpString.includes('Fennec'):
      return [null, [31, 0, 0]];

    /**
     * https://developers.whatismybrowser.com/useragents/explore/software_name/minefield/
     */

    case regExpString.includes('Minefield'):
      return [[3, 0, 0], [4, 0, 0]];

    /**
     * https://wiki.mozilla.org/Firefox/Namoroka
     */

    case regExpString.includes('Namoroka'):
      return [[3, 6, 0], [3, 6, 0]];

    /**
     * https://developers.whatismybrowser.com/useragents/explore/software_name/shiretoko
     */

    case regExpString.includes('Shiretoko'):
      return [[3, 0, 0], [3, 5, 0]];

    /**
     * https://developers.whatismybrowser.com/useragents/explore/operating_system_name/android
     */

    case regExpString.includes('CrMo'):
      return [[16, 0, 0], [16, 0, 0]];

    /**
     * https://help.opera.com/en/operas-archived-history/
     */

    case regExpString.includes('Opera)\\/9.8'):
      return [null, [12, 15, 0]];

    default:
      return [null, null];
  }
}

/* eslint-disable no-fallthrough */
const BROWSERS_REGEXPS = [// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
...extractIOSRegExp(regexps__default["default"].os), // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
...fixBrowsersRegExps(regexps__default["default"].browser)];
/**
 * Get user agent RegExps for given browsers.
 * @param browsers - Browsers.
 * @param options - Semver compare options.
 * @returns User agent RegExps.
 */

function getRegExpsForBrowsers(browsers, options) {
  const regExps = [];
  BROWSERS_REGEXPS.forEach(({
    family,
    regExp,
    fixedVersion,
    minVersion,
    maxVersion
  }) => {
    const browserVersions = browsers.get(family);

    if (browserVersions && someSemverMatched(minVersion, maxVersion, browserVersions, options) && hasVersion(fixedVersion, regExp)) {
      regExps.push({
        family,
        regExp,
        requestVersions: browserVersions,
        resultFixedVersion: fixedVersion,
        resultMinVersion: minVersion,
        resultMaxVersion: maxVersion
      });
    }
  });
  return regExps;
}
/**
 * Fix browser family.
 * @param family - Browser family.
 * @param regExp - User agent RegExp to find browser family as fallback.
 * @returns Fixed browser families.
 */

function fixBrowserFamily(family, regExp) {
  const familyOrRegExp = family || regExp;
  const regExpString = regExpToString(regExp);
  /* istanbul ignore next */

  switch (true) {
    /**
     * iOS browsers: CriOS|OPiOS|FxiOS etc
     */
    case /[^\w]?([A-Z]\w+iOS)[^\w]?/.test(regExpString):
    /**
     * iOS Outlook and UC Browser works with regular iOS RegExp
     */

    case /iPhone.*Outlook-iOS-Android|UCWEB.*iPad\|iPh/.test(regExpString):
    /**
     * This RegExp matches Safari version, not iOS
     */

    case regExpString.includes('(iPhone|iPad|iPod).*Mac OS X.*Version'):
    /**
     * YaBrowser, Mail.ru Amigo works with regular Chrome RegExp
     */

    case /YaBrowser|MRCHROME/.test(regExpString):
    /**
     * Chrome Mobile browser and WebView works with regular Chrome RegExp (except CrMo)
     */

    case /\(Chrome\).* Mobile|Mobile \.\*\(Chrome\)|; wv\\\)\.\+\(Chrome\)/.test(regExpString):
    /**
     * Firefox Mobile works with regular Firefox RegExp
     */

    case regExpString.includes('(?:Mobile|Tablet);.*(Firefox)'):
    /**
     * iOS Opera Mobile works with regular iOS RegExp
     */

    case regExpString.includes('(?:Mobile Safari).*(OPR)'):
    /**
     * Very old Opera
     */

    case /Opera.*\) \(\\d/.test(regExpString):
    /**
     * Strange RegExps
     */

    case /bingbot|^\\b\(/.test(regExpString):
      return [];

    /**
     * Chrome browsers
     * `'HeadlessChrome'` was removed, works with regular Chrome RegExp
     */

    case familyMatched(false, familyOrRegExp, ['Chrome Mobile', 'Chromium']):
      return [{
        family: 'chrome'
      }];

    case familyMatched(true, familyOrRegExp, ['Samsung Internet']):
      return [{
        family: 'samsung'
      }];

    case familyMatched(true, familyOrRegExp, ['Firefox Mobile', 'Firefox ($1)']):
      return [{
        family: 'firefox'
      }];

    case familyMatched(true, familyOrRegExp, ['IE']):
      return [{
        family: 'explorer'
      }];

    case familyMatched(true, familyOrRegExp, ['IE Mobile']):
      return [{
        family: 'explorermobile'
      }];

    case familyMatched(true, familyOrRegExp, ['BlackBerry WebKit']):
      return [{
        family: 'blackberry'
      }];

    case familyMatched(true, familyOrRegExp, ['Opera Mobile']):
      return [{
        family: 'operamobile'
      }];

    case familyOrRegExp === regExp:
      {
        const matches = /\(([\s\w\d_\-/!|]+)\)/i.exec(regExpString);
        /**
         * Extract family from RegExp
         */

        if (Array.isArray(matches)) {
          const match = matches[1];
          const familiesFromRegExp = match.split('|');
          const familyToRegExpMap = new Map();
          const families = uniq(familiesFromRegExp.map(familyFromRegExp => {
            const family = familyFromRegExp.replace(/[^\d\w]/g, '').toLowerCase();

            if (familyToRegExpMap.has(family)) {
              familyToRegExpMap.get(family).push(familyFromRegExp);
            } else {
              familyToRegExpMap.set(family, [familyFromRegExp]);
            }

            return family;
          }));
          return families.map(family => ({
            family,
            regExp: new RegExp(regExpString.replace(match, familyToRegExpMap.get(family).join('|')))
          }));
        }

        return [];
      }

    case typeof family === 'string':
      return [{
        family: family.toLowerCase()
      }];

    default:
      return [];
  }
}
/**
 * Fix browser RegExp object.
 * @param browserRegExpSource - Source browser RegExp object.
 * @returns Fixed object.
 */

function fixBrowserRegExp(browserRegExpSource) {
  const {
    [exports.BrowserRegExpSourceProp.RegExp]: regExp,
    [exports.BrowserRegExpSourceProp.Family]: family,
    [exports.BrowserRegExpSourceProp.Major]: major,
    [exports.BrowserRegExpSourceProp.Minor]: minor,
    [exports.BrowserRegExpSourceProp.Patch]: patch
  } = browserRegExpSource;
  const families = fixBrowserFamily(family, regExp);
  const fixedVersion = major === 0 ? null : semverify([major, minor, patch]);
  let minVersion = fixedVersion;
  let maxVersion = fixedVersion;
  return families.map(({
    regExp: patchedRegExp = regExp,
    ...family
  }) => {
    if (!fixedVersion) {
      [minVersion, maxVersion] = getMinMaxVersions(patchedRegExp);
    }

    return {
      regExp: patchedRegExp,
      fixedVersion,
      minVersion,
      maxVersion,
      ...family
    };
  });
}
/**
 * Fix browser RegExp objects.
 * @param browsersRegExpSoruces - Source browser RegExp objects.
 * @returns Fixed objects.
 */

function fixBrowsersRegExps(browsersRegExpSoruces) {
  const length = browsersRegExpSoruces.length;
  const regExps = [];

  for (let i = 0; i < length; i++) {
    regExps.push(...fixBrowserRegExp(browsersRegExpSoruces[i]));
  }

  return regExps;
}
/**
 * Extract and Fix iOS RegExp objects.
 * @param osRegExpSources - Source OS RegExp objects.
 * @returns Fixed objects.
 */

function extractIOSRegExp(osRegExpSources) {
  const length = osRegExpSources.length;
  const regExps = [];

  for (let i = 0; i < length; i++) {
    if (osRegExpSources[i][exports.BrowserRegExpSourceProp.Family] !== 'iOS') {
      continue;
    }

    regExps.push(...fixBrowserRegExp(osRegExpSources[i]));
  }

  return regExps;
}

/**
 * Browsers strings to info objects.
 * @param browsersList - Browsers strings with family and version.
 * @returns Browser info objects.
 */

function parseBrowsersList(browsersList) {
  return browsersList.reduce((browsers, browser) => {
    const [name, ...versions] = browser.split(/ |-/);
    const family = (BROWSERS_SHIRTNAMES[name] || name).toLowerCase();
    return versions.reduce((browsers, version) => {
      const semver = semverify(version);

      if (semver) {
        browsers.push({
          family,
          version: semver
        });
      }

      return browsers;
    }, browsers);
  }, []);
}
/**
 * Request browsers list.
 * @param options - Options to get browsers list.
 * @returns Browser info objects.
 */

function getBrowsersList(options = {}) {
  const {
    browsers,
    env,
    path
  } = options;
  const normalizedBrowsers = Array.isArray(browsers) ? browsers.map(normalizeBrowserFamily) : browsers;
  const browsersList = browserslist__default["default"](normalizedBrowsers, {
    env,
    path
  });
  const parsedBrowsers = parseBrowsersList(browsersList);
  return parsedBrowsers;
}

/**
 * Merge browser info object to map with versions.
 * @param browsers - Browser info object to merge.
 * @returns Merged browsers map.
 */

function mergeBrowserVersions(browsers) {
  const merge = new Map();
  browsers.forEach(({
    family,
    version
  }) => {
    const versions = merge.get(family);

    if (versions) {
      const strVersion = version.join('.');

      if (versions.every(_ => _.join('.') !== strVersion)) {
        versions.push(version);
      }

      return;
    }

    merge.set(family, [version]);
  });
  merge.forEach(versions => {
    versions.sort((a, b) => {
      for (const i in a) {
        if (a[i] !== b[i]) {
          return a[i] - b[i];
        }
      }

      return 0;
    });
  });
  return merge;
}
/**
 * Versions to ranged versions.
 * @param versions - Semver versions list.
 * @returns Ranged versions list.
 */

function versionsListToRanges(versions) {
  if (versions.length < 2) {
    return versions;
  }

  const max = versions.length + 1;
  const ranges = [];
  let prev = null;
  let current = versions[0];
  let major = [current[exports.SemverPart.Major]];
  let minor = [current[exports.SemverPart.Minor]];
  let patch = [current[exports.SemverPart.Patch]];
  let part = null;

  for (let i = 1; i < max; i++) {
    prev = versions[i - 1];
    current = versions[i] || [];

    for (let p = exports.SemverPart.Major; p <= exports.SemverPart.Patch; p++) {
      if ((p === part || part === null) && prev[p] + 1 === current[p] && compareArrays(prev, current, p + 1)) {
        part = p;

        if (p === exports.SemverPart.Major) {
          major.push(current[exports.SemverPart.Major]);
        } else {
          major = current[exports.SemverPart.Major];
        }

        if (p === exports.SemverPart.Minor) {
          minor.push(current[exports.SemverPart.Minor]);
        } else {
          minor = current[exports.SemverPart.Minor];
        }

        if (p === exports.SemverPart.Patch) {
          patch.push(current[exports.SemverPart.Patch]);
        } else {
          patch = current[exports.SemverPart.Patch];
        }

        break;
      }

      if (part === p || prev[p] !== current[p]) {
        ranges.push([numbersToRanges(major), numbersToRanges(minor), numbersToRanges(patch)]);
        major = [current[exports.SemverPart.Major]];
        minor = [current[exports.SemverPart.Minor]];
        patch = [current[exports.SemverPart.Patch]];
        part = null;
        break;
      }
    }
  }

  return ranges;
}
/**
 * Browser versions to ranged versions.
 * @param browsers - Browser map with versions.
 * @returns Browser map with ranged versions.
 */

function browserVersionsToRanges(browsers) {
  const ranged = new Map();
  browsers.forEach((versions, family) => {
    ranged.set(family, versionsListToRanges(versions));
  });
  return ranged;
}

const OPTIMIZABLE_GROUP = /^\([\s\w\d_\-/!]+\)$/;
const CHARCLASS_UNESCAPES = /[/.$*+?[{}|()]/;
/**
 * Optimize RegExp string:
 * - remove unnecessary braces;
 * - remove unnecessary escapes in ranges.
 * @param regExpStr - RegExp string to optimize.
 * @returns Optimized RegExp string.
 */

function optimize(regExpStr) {
  const regExpStrLength = regExpStr.length;
  let inGroup = false;
  let skip = false;
  let char = '';
  let prevChar = '';
  let nextChar = '';
  let postfix = '';
  let groupAccum = '';
  let optimizedRegExpStr = '';

  for (let i = 0; i < regExpStrLength; i++) {
    char = regExpStr[i];
    prevChar = regExpStr[i - 1];
    nextChar = regExpStr[i + 1];
    skip = skipSquareBraces(skip, prevChar, char);

    if (!skip && prevChar !== ESCAPE_SYMBOL && char === '(') {
      if (inGroup) {
        optimizedRegExpStr += groupAccum;
      }

      inGroup = true;
      groupAccum = '';
    }

    if (skip && char === ESCAPE_SYMBOL && CHARCLASS_UNESCAPES.test(nextChar)) {
      i++;
      char = nextChar;
    }

    if (inGroup) {
      groupAccum += char;
    } else {
      optimizedRegExpStr += char;
    }

    if (!skip && prevChar !== ESCAPE_SYMBOL && char === ')' && inGroup) {
      inGroup = false;
      postfix = capturePostfix(regExpStr, i + 1);
      groupAccum += postfix;

      if (groupAccum === BRACED_NUMBER_PATTERN || OPTIMIZABLE_GROUP.test(groupAccum)) {
        groupAccum = groupAccum.substr(1, groupAccum.length - 2);
      }

      optimizedRegExpStr += groupAccum;
      i += postfix.length;
    }
  }

  return optimizedRegExpStr;
}

/**
 * Get from RegExp part with number patterns.
 * @todo   Optimize.
 * 	E.g.: (HeadlessChrome)(?:\/(\d+)\.(\d+)\.(\d+))?
 * 	now: (?:\/(\d+)\.(\d+)\.(\d+))?
 * 	need: (\d+)\.(\d+)\.(\d+)
 * @param regExp - Target RegExp.
 * @param numberPatternsCount - Number patterns to extract.
 * @returns RegExp part with number patterns.
 */

function getNumberPatternsPart(regExp, numberPatternsCount) {
  const regExpStr = typeof regExp === 'string' ? regExp : regExpToString(regExp);
  const regExpStrLength = regExpStr.length;
  const maxNumbersCount = typeof numberPatternsCount === 'number' ? numberPatternsCount : getNumberPatternsCount(regExpStr);
  let braceBalance = 0;
  let skip = false;
  let numberCounter = 0;
  let char = '';
  let prevChar = '';
  let numberAccum = '';
  let numberPatternsPart = '';

  for (let i = 0; i < regExpStrLength; i++) {
    char = regExpStr[i];
    prevChar = regExpStr[i - 1];
    skip = skipSquareBraces(skip, prevChar, char);

    if (!skip && prevChar !== ESCAPE_SYMBOL && char === '(') {
      braceBalance++;
      numberAccum = '';
    }

    if (braceBalance > 0 || numberCounter > 0) {
      numberPatternsPart += char;
      numberAccum += char;
    }

    if (!skip && prevChar !== ESCAPE_SYMBOL && char === ')' && braceBalance > 0) {
      braceBalance--;

      if (numberAccum === BRACED_NUMBER_PATTERN) {
        numberCounter++;
      }

      if (braceBalance === 0 && numberCounter === 0) {
        numberPatternsPart = '';
      }

      if (braceBalance === 0 && numberCounter >= maxNumbersCount) {
        numberPatternsPart += capturePostfix(regExpStr, ++i);
        break;
      }
    }
  }

  return numberPatternsPart;
}

/**
 * Apply ranged sevmers to the RegExp.
 * @todo   if `allowHigherVersions`, apply only min version.
 * @param regExp - Target RegExp.
 * @param versions - Ranged semvers.
 * @param options - Semver compare options.
 * @returns RegExp with given versions.
 */

function applyVersionsToRegExp(regExp, versions, options) {
  let maxRequiredPartsCount = 1;
  const regExpStr = typeof regExp === 'string' ? regExp : regExpToString(regExp);
  const numberPatternsCount = getNumberPatternsCount(regExpStr);
  const suitableVersions = versions.map(version => {
    const requiredPartsCount = getRequiredSemverPartsCount(version, options);
    maxRequiredPartsCount = Math.max(maxRequiredPartsCount, requiredPartsCount);
    return numberPatternsCount >= requiredPartsCount ? version : null;
  }).filter(Boolean);

  if (!suitableVersions.length) {
    return null;
  }

  const numberPatternsPart = getNumberPatternsPart(regExpStr, maxRequiredPartsCount);
  const versionsRegExpPart = joinParts(uniq([].concat(...suitableVersions.map(version => rangedSemverToRegExp(version, options).map(parts => replaceNumberPatterns(numberPatternsPart, parts, maxRequiredPartsCount))))));
  const regExpWithVersions = regExpStr.replace(numberPatternsPart, versionsRegExpPart);
  return regExpWithVersions;
}
/**
 * Apply browser versions to info objects.
 * @param browserVersionRegExps - Objects with requested browser version and RegExp.
 * @param browsers - Ranged versions of browsers.
 * @param options - Semver compare options.
 * @returns Objects with requested browser version and RegExp special for this version.
 */

function applyVersionsToRegExps(browserVersionRegExps, browsers, options) {
  const versionedRegExps = [];
  browserVersionRegExps.forEach(({
    family,
    regExp: sourceRegExp,
    resultFixedVersion,
    requestVersions,
    ...other
  }) => {
    const sourceRegExpString = regExpToString(sourceRegExp);
    let regExp = null;
    let regExpString = '';

    if (resultFixedVersion) {
      regExp = sourceRegExp;
      regExpString = sourceRegExpString;
    } else {
      regExpString = applyVersionsToRegExp(sourceRegExpString, browsers.get(family), options);
      regExp = new RegExp(regExpString);
    }

    if (regExpString && regExp) {
      versionedRegExps.push({
        family,
        sourceRegExp,
        sourceRegExpString,
        regExp,
        regExpString,
        resultFixedVersion,
        requestVersions,
        requestVersionsStrings: requestVersions.map(_ => isAllVersion(_) ? String(_[0]) : _.join('.')),
        ...other
      });
    }
  });
  return versionedRegExps;
}

/**
 * Optimize all RegExps.
 * @param regExps - Objects with info about compiled RegExps.
 * @returns Objects with info about optimized RegExps.
 */

function optimizeAll(regExps) {
  return regExps.map(({
    regExpString,
    ...regExp
  }) => {
    const optimizedRegExpStr = optimize(regExpString);
    const optimizedRegExp = new RegExp(optimizedRegExpStr);
    return { ...regExp,
      regExp: optimizedRegExp,
      regExpString: optimizedRegExpStr
    };
  });
}

const patches = [
/**
 * Patch Chrome < 74 regexp to exclude Edge <= 18
 * 1) Last ever (?) EdgeHTML version is 18 (https://en.wikipedia.org/wiki/Microsoft_Edge)
 * 2) First known Chromium Edge has Chrome 74 version
 *    (https://blogs.windows.com/msedgedev/2019/04/08/microsoft-edge-preview-channel-details/#HzAbspiQ4poHQRVc.97)
 */
{
  test(browsers) {
    const chromeVersions = browsers.get('chrome');
    const edgeVersions = browsers.get('edge');
    const hasBrowsers = chromeVersions && edgeVersions;

    if (!hasBrowsers) {
      return false;
    }

    const minChromeVersion = chromeVersions[0][0];
    const minEdgeVersion = edgeVersions[0][0];
    return minChromeVersion < 74 && minEdgeVersion <= 18;
  },

  patch(regExpInfo) {
    const {
      family,
      regExpString,
      resultMinVersion
    } = regExpInfo;

    if (family !== 'chrome' || resultMinVersion && resultMinVersion[0] >= 74 || regExpString.includes('HeadlessChrome')) {
      return regExpInfo;
    } // Iridium browser has Safari before Chrome


    const patchedRegExpString = `${regExpString}([\\d.]+$|.*Safari\\/(?![\\d.]+ Edge\\/[\\d.]+$))`;
    const patchedRegExp = new RegExp(patchedRegExpString);
    return { ...regExpInfo,
      regExp: patchedRegExp,
      regExpString: patchedRegExpString
    };
  }

},
/**
 * Patch Desktop Safari regexp to exclude Chrome and etc.
 */
{
  test(browsers) {
    return browsers.has('safari');
  },

  patch(regExpInfo) {
    const {
      family,
      regExpString
    } = regExpInfo;

    if (family !== 'safari') {
      return regExpInfo;
    }

    const patchedRegExpString = regExpString.replace(/\.\*(Safari\\\/)/, ' $1');
    const patchedRegExp = new RegExp(patchedRegExpString);
    return { ...regExpInfo,
      regExp: patchedRegExp,
      regExpString: patchedRegExpString
    };
  }

}];
function patchRegExps(regExps, browsers) {
  const tested = new Map();
  /* istanbul ignore next */

  return regExps.map(regExp => patches.reduce((regExp, patch) => {
    if (!tested.has(patch)) {
      tested.set(patch, patch.test(browsers));
    }

    if (tested.get(patch)) {
      return patch.patch(regExp);
    }

    return regExp;
  }, regExp));
}

const defaultOptions = {
  ignoreMinor: false,
  ignorePatch: true,
  allowZeroSubversions: false,
  allowHigherVersions: false
};
/**
 * Compile browserslist query to RegExps.
 * @param options - Browserslist and semver compare options.
 * @returns Objects with info about compiled RegExps.
 */

function getUserAgentRegExps(options = {}) {
  const {
    browsers,
    env,
    path,
    ...otherOptions
  } = options;
  const finalOptions = { ...defaultOptions,
    ...otherOptions
  };
  const browsersList = getBrowsersList({
    browsers,
    env,
    path
  });
  const mergedBrowsers = mergeBrowserVersions(browsersList);
  const rangedBrowsers = browserVersionsToRanges(mergedBrowsers);
  const sourceRegExps = getRegExpsForBrowsers(mergedBrowsers, finalOptions);
  const versionedRegExps = applyVersionsToRegExps(sourceRegExps, rangedBrowsers, finalOptions);
  const patchedRegExps = patchRegExps(versionedRegExps, mergedBrowsers);
  const optimizedRegExps = optimizeAll(patchedRegExps);
  return optimizedRegExps;
}
/**
 * Compile browserslist query to RegExp.
 * @param options - Browserslist and semver compare options.
 * @returns Compiled RegExp.
 */

function getUserAgentRegExp(options = {}) {
  const regExps = getUserAgentRegExps(options);
  const regExpStr = joinVersionedBrowsersRegExps(regExps);
  const regExp = new RegExp(regExpStr);
  return regExp;
}

exports.BRACED_NUMBER_PATTERN = BRACED_NUMBER_PATTERN;
exports.BROWSERS_REGEXPS = BROWSERS_REGEXPS;
exports.BROWSERS_SHIRTNAMES = BROWSERS_SHIRTNAMES;
exports.BROWSERS_SHIRTNAMES_REGEXP = BROWSERS_SHIRTNAMES_REGEXP;
exports.CHARCLASS_UNESCAPES = CHARCLASS_UNESCAPES;
exports.DIGIT_PATTERN = DIGIT_PATTERN;
exports.ESCAPE_SYMBOL = ESCAPE_SYMBOL;
exports.NUMBER_PATTERN = NUMBER_PATTERN;
exports.OPTIMIZABLE_GROUP = OPTIMIZABLE_GROUP;
exports.applyVersionsToRegExp = applyVersionsToRegExp;
exports.applyVersionsToRegExps = applyVersionsToRegExps;
exports.browserVersionsToRanges = browserVersionsToRanges;
exports.capturePostfix = capturePostfix;
exports.compareArrays = compareArrays;
exports.compareSemvers = compareSemvers;
exports.defaultOptions = defaultOptions;
exports.enumOrRange = enumOrRange;
exports.extractIOSRegExp = extractIOSRegExp;
exports.familyMatched = familyMatched;
exports.fixBrowserFamily = fixBrowserFamily;
exports.fixBrowserRegExp = fixBrowserRegExp;
exports.fixBrowsersRegExps = fixBrowsersRegExps;
exports.getBrowsersList = getBrowsersList;
exports.getMinMaxVersions = getMinMaxVersions;
exports.getNumberPatternsCount = getNumberPatternsCount;
exports.getNumberPatternsPart = getNumberPatternsPart;
exports.getRegExpsForBrowsers = getRegExpsForBrowsers;
exports.getRequiredSemverPartsCount = getRequiredSemverPartsCount;
exports.getUserAgentRegExp = getUserAgentRegExp;
exports.getUserAgentRegExps = getUserAgentRegExps;
exports.hasNumberPattern = hasNumberPattern;
exports.hasVersion = hasVersion;
exports.isAllVersion = isAllVersion;
exports.joinParts = joinParts;
exports.joinVersionedBrowsersRegExps = joinVersionedBrowsersRegExps;
exports.mergeBrowserVersions = mergeBrowserVersions;
exports.normalizeBrowserFamily = normalizeBrowserFamily;
exports.numberToDigits = numberToDigits;
exports.numbersToRanges = numbersToRanges;
exports.optimize = optimize;
exports.optimizeAll = optimizeAll;
exports.optimizeRaysNumberPatterns = optimizeRaysNumberPatterns;
exports.parseBrowsersList = parseBrowsersList;
exports.patchRegExps = patchRegExps;
exports.rangeToRegExp = rangeToRegExp;
exports.rangedSemverToRegExp = rangedSemverToRegExp;
exports.rayRangeDigitPattern = rayRangeDigitPattern;
exports.rayToNumberPatterns = rayToNumberPatterns;
exports.regExpToString = regExpToString;
exports.replaceNumberPatterns = replaceNumberPatterns;
exports.segmentRangeNumberPattern = segmentRangeNumberPattern;
exports.segmentToNumberPatterns = segmentToNumberPatterns;
exports.segmentToNumberPatternsOrEnum = segmentToNumberPatternsOrEnum;
exports.semverify = semverify;
exports.skipSquareBraces = skipSquareBraces;
exports.someSemverMatched = someSemverMatched;
exports.splitCommonDiff = splitCommonDiff;
exports.splitToDecadeRanges = splitToDecadeRanges;
exports.uniq = uniq;
exports.uniqItems = uniqItems;
exports.versionsListToRanges = versionsListToRanges;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbXSwic291cmNlc0NvbnRlbnQiOltdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9

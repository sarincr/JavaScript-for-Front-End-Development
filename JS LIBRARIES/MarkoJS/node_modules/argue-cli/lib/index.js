'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

const argvStartIndex = 2;
const shirtArgLength = 2;

const argv = process.argv.slice(argvStartIndex, process.argv.length);

function findName(name, names) {

	let findedName = false,
	    array = false;

	names.some(fullNameOrigin => {

		let keys = null,
		    fullName = fullNameOrigin,
		    shirtName = null;

		if (typeof fullName == 'string') {

			if (fullName == name) {
				findedName = fullName;
				return true;
			}

			return false;
		}

		const proto = Object.getPrototypeOf(fullName); // eslint-disable-line

		if (proto == Object.prototype) {

			keys = fullName;
			fullName = Object.keys(keys)[0];
			shirtName = keys[fullName];

			if (fullName == name || shirtName == name) {
				findedName = fullName;
				return true;
			}

			return false;
		}

		if (proto == Array.prototype) {
			var _fullName = fullName;

			var _fullName2 = _slicedToArray(_fullName, 2);

			fullName = _fullName2[0];
			shirtName = _fullName2[1];


			if (fullName == name || shirtName == name) {
				array = true;
				findedName = fullName;
				return true;
			}

			return false;
		}

		return false;
	});

	return findedName ? { name: findedName, isArray: array } : false;
}

function setArguments(...newArguments) {
	argv.splice(0, argv.length);
	argv.push(...newArguments);
}

/**
 * Strict expectation one of given commands.
 *
 *     command-line-app install
 *
 *     expect(
 *         {"install": "i"}, - fullname and shirtname
 *         ["update", "u"],  - also fullname and shirtname
 *         "info"            - only one variant of name
 *     )
 *
 * @param  {...Object} names    array of expected tokens
 * @return {String}    fullname
 */
function expect(...names) {

	if (!argv.length) {
		throw new Error('Unexpected end of arguments.');
	}

	const sourceKey = argv.shift(),
	      argument = findName(sourceKey, names);

	if (!argument) {
		throw new Error(`Unexpected argument "${sourceKey}".`);
	}

	return argument.name;
}

/**
 * Strict reading of argument.
 *
 *     command-line-app some-value
 *
 * @return {String} argument
 */
function read() {

	if (!argv.length) {
		throw new Error('Unexpected end of arguments.');
	}

	return argv.shift();
}

/**
 * Strict expectation of end.
 * @returns {void}
 */
function end() {

	if (argv.length) {
		throw new Error(`Unexpected argument "${argv[0]}".`);
	}
}

/**
 * Strict reading of flags and options.
 *
 *     command-line-app --output test -p es2015,react --verbose
 *
 *     strictOptions([
 *         ["another"]      - for flags array is same as object notation
 *         "verbose"        - only one variant of name
 *     ], [
 *         {"output": "o"}, - fullname and shirtname
 *         ["plugins", "p"] - fullname and shirtname for array
 *     ])
 *
 * @param  {...Object} flagsNames   array of tokens
 * @param  {...Object} optionsNames array of tokens
 * @return {Object}    fullname-value pairs
 */
function strictOptions(flagsNames, optionsNames) {

	if (!argv.length) {
		return {};
	}

	const options = {};

	let argument = argv[0];

	while (argv.length && (argument.indexOf('--') == 0 || argument.indexOf('-') == 0 && argument.length == shirtArgLength)) {

		const sourceKey = argv.shift().replace(/^(--|-)/, ''),
		      flagKey = findName(sourceKey, flagsNames),
		      optionKey = findName(sourceKey, optionsNames);

		if (!flagKey && !optionKey) {
			throw new Error(`Unexpected key "${sourceKey}".`);
		}

		if (!flagKey && optionKey && !argv.length) {
			throw new Error(`Unexpected end of arguments.`);
		}

		let value = argv[0];

		if (optionKey && value.indexOf('--') != 0 && value.indexOf('-') != 0) {

			argv.shift();

			if (optionKey.isArray) {
				value = value.split(',').map(element => element.replace(/^['"]|["']$/g, ''));
			} else {
				value = value.replace(/^['"]|["']$/g, '');
			}

			options[optionKey.name] = value;
		} else if (flagKey) {

			options[flagKey.name] = true;
		} else {
			throw new Error(`Unexpected key "${value}".`);
		}

		argument = argv[0];
	}

	return options;
}

/**
 * Strict reading of options with equal sign.
 * If option is provided without value it will interpreted as `true`.
 *
 *     command-line-app --output=test -p=es2015,react --verbose
 *
 *     strictOptionsEqual(
 *         {"output": "o"},  - fullname and shirtname
 *         ["plugins", "p"], - fullname and shirtname for array
 *         "verbose"         - only one variant of name
 *     )
 *
 * @param  {...Object} names array of tokens
 * @return {Object}    fullname-value pairs
 */
function strictOptionsEqual(...names) {

	if (!argv.length) {
		return {};
	}

	const options = {};

	let argument = argv[0];

	while (argv.length && (argument.indexOf('--') == 0 || argument.indexOf('-') == 0)) {
		var _argv$shift$replace$s = argv.shift().replace(/^(--|-)/, '').split('='),
		    _argv$shift$replace$s2 = _slicedToArray(_argv$shift$replace$s, 2);

		let sourceKey = _argv$shift$replace$s2[0],
		    value = _argv$shift$replace$s2[1];


		const key = findName(sourceKey, names);

		if (!key) {
			throw new Error(`Unexpected key "${sourceKey}".`);
		}

		if (typeof value == 'undefined') {
			value = true;
		} else if (key.isArray) {
			value = value.split(',').map(element => element.replace(/^['"]|["']$/g, ''));
		} else {
			value = value.replace(/^['"]|["']$/g, '');
		}

		options[key.name] = value;

		argument = argv[0];
	}

	return options;
}

/**
 * Unlimited reading of flags and options.
 *
 *     command-line-app --output test install -p es2015,react babel --verbose
 *
 *     options([
 *         ["another"]      - for flags array is same as object notation
 *         "verbose"        - only one variant of name
 *     ], [
 *         {"output": "o"}, - fullname and shirtname
 *         ["plugins", "p"] - fullname and shirtname for array
 *     ])
 *
 * @param  {...Object} flagsNames   array of tokens
 * @param  {...Object} optionsNames array of tokens
 * @return {Object}    fullname-value pairs
 */
function options(flagsNames, optionsNames) {

	if (!argv.length) {
		return {};
	}

	const options = {},
	      argvc = argv.slice(),
	      argc = argvc.length,
	      remove = [];

	for (let i = 0, argument = argvc[i]; i < argc; argument = argvc[++i]) {

		if (argument.indexOf('--') != 0 && argument.indexOf('-') != 0) {
			continue;
		}

		const sourceKey = argument.replace(/^(--|-)/, ''),
		      flagKey = findName(sourceKey, flagsNames),
		      optionKey = findName(sourceKey, optionsNames);

		if (!flagKey && !optionKey) {
			throw new Error(`Unexpected key "${sourceKey}".`);
		}

		if (!flagKey && optionKey && i == argc - 1) {
			throw new Error(`Unexpected end of arguments.`);
		}

		let value = argvc[i + 1];

		if (optionKey && value.indexOf('--') != 0 && value.indexOf('-') != 0) {

			remove.unshift(i++);

			if (optionKey.isArray) {
				value = value.split(',').map(element => element.replace(/^['"]|["']$/g, ''));
			} else {
				value = value.replace(/^['"]|["']$/g, '');
			}

			options[optionKey.name] = value;
		} else if (flagKey) {

			options[flagKey.name] = true;
		} else {
			throw new Error(`Unexpected key "${value}".`);
		}

		remove.unshift(i);
	}

	remove.forEach(index => argv.splice(index, 1));

	return options;
}

/**
 * Unlimited reading of with equal sign.
 * If option is provided without value it will interpreted as `true`.
 *
 *     command-line-app --output=test install -p=es2015,react babel --verbose
 *
 *     optionsEqual(
 *         {"output": "o"},  - fullname and shirtname
 *         ["plugins", "p"], - fullname and shirtname for array
 *         "verbose"         - only one variant of name
 *     )
 *
 * @param  {...Object} names array of tokens
 * @return {Object}    fullname-value pairs
 */
function optionsEqual(...names) {

	if (!argv.length) {
		return {};
	}

	const options = {},
	      argvc = argv.slice(),
	      argc = argvc.length,
	      remove = [];

	for (let i = 0, argument = argvc[i]; i < argc; argument = argvc[++i]) {

		if (argument.indexOf('-') != 0) {
			continue;
		}

		var _argument$replace$spl = argument.replace(/^(--|-)/, '').split('='),
		    _argument$replace$spl2 = _slicedToArray(_argument$replace$spl, 2);

		let sourceKey = _argument$replace$spl2[0],
		    value = _argument$replace$spl2[1];


		const key = findName(sourceKey, names);

		remove.unshift(i);

		if (!key) {
			throw new Error(`Unexpected key "${sourceKey}".`);
		}

		if (typeof value == 'undefined') {
			value = true;
		} else if (key.isArray) {
			value = value.split(',').map(element => element.replace(/^['"]|["']$/g, ''));
		} else {
			value = value.replace(/^['"]|["']$/g, '');
		}

		options[key.name] = value;
	}

	remove.forEach(index => argv.splice(index, 1));

	return options;
}

exports.argv = argv;
exports.setArguments = setArguments;
exports.expect = expect;
exports.read = read;
exports.end = end;
exports.strictOptions = strictOptions;
exports.strictOptionsEqual = strictOptionsEqual;
exports.options = options;
exports.optionsEqual = optionsEqual;
//# sourceMappingURL=index.js.map

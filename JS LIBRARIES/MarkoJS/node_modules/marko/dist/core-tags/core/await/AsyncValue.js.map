{"version":3,"sources":["../../../../src/core-tags/core/await/AsyncValue.js"],"names":["queueMicrotask","require","AsyncValue","undefined","notifyCallbacks","asyncValue","err","value","callbacks","i","length","callback","prototype","push","then","finalPromise","onFulfilled","bind","onRejected","done","module","exports"],"mappings":"aAAA,IAAIA,cAAc,GAAGC,OAAO,CAAC,iCAAD,CAA5B;;AAEA,SAASC,UAAT,GAAsB;AACpB;AACF;AACA;AACA;AACE,YAAgBC,SAAhB;;AAEA;AACF;AACA;AACA;AACE,YAAgBA,SAAhB;;AAEA;AACF;AACA;AACE,YAAoBA,SAApB;;AAEA;AACF;AACA;AACE,YAAkB,KAAlB;AACD;;AAED,SAASC,eAAT,CAAyBC,UAAzB,EAAqCC,GAArC,EAA0CC,KAA1C,EAAiD;AAC/C,MAAIC,SAAS,GAAGH,UAAU,GAA1B;AACA,MAAIG,SAAJ,EAAe;AACb;AACAH,IAAAA,UAAU,GAAV,GAA0BF,SAA1B;;AAEA;AACA,SAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,SAAS,CAACE,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AACzC;AACA,UAAIE,QAAQ,GAAGH,SAAS,CAACC,CAAD,CAAxB;AACAE,MAAAA,QAAQ,CAACL,GAAD,EAAMC,KAAN,CAAR;AACD;AACF;AACF;;AAEDL,UAAU,CAACU,SAAX,GAAuB;AACrB;AACF;AACA;AACA;AACA;AACA;AACE,MAAS,UAAUD,QAAV,EAAoB;AAC3B;AACA,QAAI,OAAJ,EAAqB;AACnB;AACA,aAAOA,QAAQ,CAAC,OAAD,EAAgB,OAAhB,CAAf;AACD;;AAED,QAAIH,SAAS,GAAG,YAAsB,UAAoB,EAA1C,CAAhB;AACAA,IAAAA,SAAS,CAACK,IAAV,CAAeF,QAAf;AACD,GAhBoB;;AAkBrB;AACF;AACA;AACA;AACA;AACA;AACE,MAAW,UAAUL,GAAV,EAAe;AACxB,QAAI,OAAJ,EAAqB;AACnB;AACD;;AAED;AACA,cAAgBA,GAAhB;;AAEA;AACA;AACA;AACA;AACA,cAAkB,IAAlB;;AAEA;AACAF,IAAAA,eAAe,CAAC,IAAD,EAAOE,GAAP,EAAY,IAAZ,CAAf;AACD,GAxCoB;;AA0CrB;AACF;AACA;AACE,MAAY,UAAUC,KAAV,EAAiB;AAC3B,QAAI,OAAJ,EAAqB;AACnB;AACD;;AAED,QAAIA,KAAK,IAAI,OAAOA,KAAK,CAACO,IAAb,KAAsB,UAAnC,EAA+C;AAC7C,UAAIT,UAAU,GAAG,IAAjB;;AAEA,UAAIU,YAAY,GAAGR,KAAK,CAACO,IAAN;AACjB,eAASE,WAAT,CAAqBT,KAArB,EAA4B;AAC1BP,QAAAA,cAAc,CAACK,UAAU,GAAV,CAAsBY,IAAtB,CAA2BZ,UAA3B,EAAuCE,KAAvC,CAAD,CAAd;AACD,OAHgB;AAIjB,eAASW,UAAT,CAAoBZ,GAApB,EAAyB;AACvBN,QAAAA,cAAc,CAACK,UAAU,GAAV,CAAqBY,IAArB,CAA0BZ,UAA1B,EAAsCC,GAAtC,CAAD,CAAd;AACD,OANgB,CAAnB;;;AASA,UAAIS,YAAY,CAACI,IAAjB,EAAuB;AACrBJ,QAAAA,YAAY,CAACI,IAAb;AACD;AACF,KAfD,MAeO;AACL;AACA,gBAAgBZ,KAAhB;;AAEA;AACA,gBAAkB,IAAlB;;AAEA;AACAH,MAAAA,eAAe,CAAC,IAAD,EAAO,IAAP,EAAaG,KAAb,CAAf;AACD;AACF,GA3EoB,EAAvB;;;AA8EAa,MAAM,CAACC,OAAP,GAAiBnB,UAAjB","sourcesContent":["var queueMicrotask = require(\"../../../runtime/queueMicrotask\");\n\nfunction AsyncValue() {\n  /**\n   * The data that was provided via call to resolve(data).\n   * This property is assumed to be public and available for inspection.\n   */\n  this.___value = undefined;\n\n  /**\n   * The data that was provided via call to reject(err)\n   * This property is assumed to be public and available for inspection.\n   */\n  this.___error = undefined;\n\n  /**\n   * The queue of callbacks that are waiting for data\n   */\n  this.___callbacks = undefined;\n\n  /**\n   * The state of the data holder (STATE_INITIAL, STATE_RESOLVED, or STATE_REJECTED)\n   */\n  this.___settled = false;\n}\n\nfunction notifyCallbacks(asyncValue, err, value) {\n  var callbacks = asyncValue.___callbacks;\n  if (callbacks) {\n    // clear out the registered callbacks (we still have reference to the original value)\n    asyncValue.___callbacks = undefined;\n\n    // invoke all of the callbacks and use their scope\n    for (var i = 0; i < callbacks.length; i++) {\n      // each callback is actually an object with \"scope and \"callback\" properties\n      var callback = callbacks[i];\n      callback(err, value);\n    }\n  }\n}\n\nAsyncValue.prototype = {\n  /**\n   * Adds a callback to the queue. If there is not a pending request to load data\n   * and we have a \"loader\" then we will use that loader to request the data.\n   * The given callback will be invoked when there is an error or resolved data\n   * available.\n   */\n  ___done: function (callback) {\n    // Do we already have data or error?\n    if (this.___settled) {\n      // invoke the callback immediately\n      return callback(this.___error, this.___value);\n    }\n\n    var callbacks = this.___callbacks || (this.___callbacks = []);\n    callbacks.push(callback);\n  },\n\n  /**\n   * This method will trigger any callbacks to be notified of rejection (error).\n   * If this data holder has a loader then the data holder will be returned to\n   * its initial state so that any future requests to load data will trigger a\n   * new load call.\n   */\n  ___reject: function (err) {\n    if (this.___settled) {\n      return;\n    }\n\n    // remember the error\n    this.___error = err;\n\n    // Go to the rejected state if we don't have a loader.\n    // If we do have a loader then return to the initial state\n    // (we do this so that next call to done() will trigger load\n    // again in case the error was transient).\n    this.___settled = true;\n\n    // always notify callbacks regardless of whether or not we return to the initial state\n    notifyCallbacks(this, err, null);\n  },\n\n  /**\n   * This method will trigger any callbacks to be notified of data.\n   */\n  ___resolve: function (value) {\n    if (this.___settled) {\n      return;\n    }\n\n    if (value && typeof value.then === \"function\") {\n      var asyncValue = this;\n\n      var finalPromise = value.then(\n        function onFulfilled(value) {\n          queueMicrotask(asyncValue.___resolve.bind(asyncValue, value));\n        },\n        function onRejected(err) {\n          queueMicrotask(asyncValue.___reject.bind(asyncValue, err));\n        }\n      );\n\n      if (finalPromise.done) {\n        finalPromise.done();\n      }\n    } else {\n      // remember the state\n      this.___value = value;\n\n      // go to the resolved state\n      this.___settled = true;\n\n      // notify callbacks\n      notifyCallbacks(this, null, value);\n    }\n  }\n};\n\nmodule.exports = AsyncValue;\n"],"file":"AsyncValue.js"}
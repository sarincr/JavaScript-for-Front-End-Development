"use strict";var queueMicrotask = require("../../../runtime/queueMicrotask");

function AsyncValue() {
  /**
   * The data that was provided via call to resolve(data).
   * This property is assumed to be public and available for inspection.
   */
  this.q_ = undefined;

  /**
   * The data that was provided via call to reject(err)
   * This property is assumed to be public and available for inspection.
   */
  this.r_ = undefined;

  /**
   * The queue of callbacks that are waiting for data
   */
  this.s_ = undefined;

  /**
   * The state of the data holder (STATE_INITIAL, STATE_RESOLVED, or STATE_REJECTED)
   */
  this.t_ = false;
}

function notifyCallbacks(asyncValue, err, value) {
  var callbacks = asyncValue.s_;
  if (callbacks) {
    // clear out the registered callbacks (we still have reference to the original value)
    asyncValue.s_ = undefined;

    // invoke all of the callbacks and use their scope
    for (var i = 0; i < callbacks.length; i++) {
      // each callback is actually an object with "scope and "callback" properties
      var callback = callbacks[i];
      callback(err, value);
    }
  }
}

AsyncValue.prototype = {
  /**
   * Adds a callback to the queue. If there is not a pending request to load data
   * and we have a "loader" then we will use that loader to request the data.
   * The given callback will be invoked when there is an error or resolved data
   * available.
   */
  u_: function (callback) {
    // Do we already have data or error?
    if (this.t_) {
      // invoke the callback immediately
      return callback(this.r_, this.q_);
    }

    var callbacks = this.s_ || (this.s_ = []);
    callbacks.push(callback);
  },

  /**
   * This method will trigger any callbacks to be notified of rejection (error).
   * If this data holder has a loader then the data holder will be returned to
   * its initial state so that any future requests to load data will trigger a
   * new load call.
   */
  v_: function (err) {
    if (this.t_) {
      return;
    }

    // remember the error
    this.r_ = err;

    // Go to the rejected state if we don't have a loader.
    // If we do have a loader then return to the initial state
    // (we do this so that next call to done() will trigger load
    // again in case the error was transient).
    this.t_ = true;

    // always notify callbacks regardless of whether or not we return to the initial state
    notifyCallbacks(this, err, null);
  },

  /**
   * This method will trigger any callbacks to be notified of data.
   */
  w_: function (value) {
    if (this.t_) {
      return;
    }

    if (value && typeof value.then === "function") {
      var asyncValue = this;

      var finalPromise = value.then(
      function onFulfilled(value) {
        queueMicrotask(asyncValue.w_.bind(asyncValue, value));
      },
      function onRejected(err) {
        queueMicrotask(asyncValue.v_.bind(asyncValue, err));
      });


      if (finalPromise.done) {
        finalPromise.done();
      }
    } else {
      // remember the state
      this.q_ = value;

      // go to the resolved state
      this.t_ = true;

      // notify callbacks
      notifyCallbacks(this, null, value);
    }
  } };


module.exports = AsyncValue;
//# sourceMappingURL=AsyncValue.js.map
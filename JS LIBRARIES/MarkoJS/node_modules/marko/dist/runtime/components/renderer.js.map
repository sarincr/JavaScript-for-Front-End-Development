{"version":3,"sources":["../../../src/runtime/components/renderer.js"],"names":["componentsUtil","require","componentLookup","ComponentsContext","getComponentsContext","registry","copyProps","isServer","beginComponent","endComponent","COMPONENT_BEGIN_ASYNC_ADDED_KEY","resolveComponentKey","key","parentComponentDef","substring","id","trackAsyncComponents","out","isSync","global","on","handleBeginAsync","handleBeginDetachedAsync","event","parentOut","asyncOut","componentsContext","undefined","c","createRendererFunc","templateRenderFunc","componentProps","renderingLogic","onInput","typeName","t","isSplit","s","isImplicitComponent","i","shouldApplySplitMixins","d","Error","renderer","input","globalComponentsContext","component","isRerender","isExisting","customEvents","ownerComponentDef","ownerComponentId","toString","destroy","renderingLogicProps","prototype","constructor","shouldUpdate","componentDef","module","exports"],"mappings":"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","sourcesContent":["var componentsUtil = require(\"./util\");\nvar componentLookup = componentsUtil.___componentLookup;\n\nvar ComponentsContext = require(\"./ComponentsContext\");\nvar getComponentsContext = ComponentsContext.___getComponentsContext;\nvar registry = require(\"./registry\");\nvar copyProps = require(\"raptor-util/copyProps\");\nvar isServer = componentsUtil.___isServer === true;\nvar beginComponent = require(\"./beginComponent\");\nvar endComponent = require(\"./endComponent\");\n\nvar COMPONENT_BEGIN_ASYNC_ADDED_KEY = \"$wa\";\n\nfunction resolveComponentKey(key, parentComponentDef) {\n  if (key[0] === \"#\") {\n    return key.substring(1);\n  } else {\n    return parentComponentDef.id + \"-\" + parentComponentDef.___nextKey(key);\n  }\n}\n\nfunction trackAsyncComponents(out) {\n  if (out.isSync() || out.global[COMPONENT_BEGIN_ASYNC_ADDED_KEY]) {\n    return;\n  }\n\n  out.on(\"beginAsync\", handleBeginAsync);\n  out.on(\"beginDetachedAsync\", handleBeginDetachedAsync);\n  out.global[COMPONENT_BEGIN_ASYNC_ADDED_KEY] = true;\n}\n\nfunction handleBeginAsync(event) {\n  var parentOut = event.parentOut;\n  var asyncOut = event.out;\n  var componentsContext = parentOut.___components;\n\n  if (componentsContext !== undefined) {\n    // We are going to start a nested ComponentsContext\n    asyncOut.___components = new ComponentsContext(asyncOut, componentsContext);\n  }\n  // Carry along the component arguments\n  asyncOut.c(\n    parentOut.___assignedComponentDef,\n    parentOut.___assignedKey,\n    parentOut.___assignedCustomEvents\n  );\n}\n\nfunction handleBeginDetachedAsync(event) {\n  var asyncOut = event.out;\n  handleBeginAsync(event);\n  asyncOut.on(\"beginAsync\", handleBeginAsync);\n  asyncOut.on(\"beginDetachedAsync\", handleBeginDetachedAsync);\n}\n\nfunction createRendererFunc(\n  templateRenderFunc,\n  componentProps,\n  renderingLogic\n) {\n  var onInput = renderingLogic && renderingLogic.onInput;\n  var typeName = componentProps.t;\n  var isSplit = componentProps.s === true;\n  var isImplicitComponent = componentProps.i === true;\n\n  var shouldApplySplitMixins = renderingLogic && isSplit;\n\n  // eslint-disable-next-line no-constant-condition\n  if (\"MARKO_DEBUG\") {\n    if (!componentProps.d) {\n      throw new Error(\n        \"Component was compiled in a different NODE_ENV than the Marko runtime is using.\"\n      );\n    }\n  } else if (componentProps.d) {\n    throw new Error(\"Runtime/NODE_ENV Mismatch\");\n  }\n\n  return function renderer(input, out) {\n    trackAsyncComponents(out);\n\n    var componentsContext = getComponentsContext(out);\n    var globalComponentsContext = componentsContext.___globalContext;\n\n    var component = globalComponentsContext.___rerenderComponent;\n    var isRerender = component !== undefined;\n    var id;\n    var isExisting;\n    var customEvents;\n    var parentComponentDef = componentsContext.___componentDef;\n    var ownerComponentDef = out.___assignedComponentDef;\n    var ownerComponentId = ownerComponentDef && ownerComponentDef.id;\n    var key = out.___assignedKey;\n\n    if (component) {\n      // If component is provided then we are currently rendering\n      // the top-level UI component as part of a re-render\n      id = component.id; // We will use the ID of the component being re-rendered\n      isExisting = true; // This is a re-render so we know the component is already in the DOM\n      globalComponentsContext.___rerenderComponent = null;\n    } else {\n      // Otherwise, we are rendering a nested UI component. We will need\n      // to match up the UI component with the component already in the\n      // DOM (if any) so we will need to resolve the component ID from\n      // the assigned key. We also need to handle any custom event bindings\n      // that were provided.\n      if (parentComponentDef) {\n        // console.log('componentArgs:', componentArgs);\n        customEvents = out.___assignedCustomEvents;\n\n        if (key != null) {\n          id = resolveComponentKey(key.toString(), parentComponentDef);\n        } else {\n          id = parentComponentDef.___nextComponentId();\n        }\n      } else {\n        id = globalComponentsContext.___nextComponentId();\n      }\n    }\n\n    if (isServer) {\n      // If we are rendering on the server then things are simplier since\n      // we don't need to match up the UI component with a previously\n      // rendered component already mounted to the DOM. We also create\n      // a lightweight ServerComponent\n      component = registry.___createComponent(\n        renderingLogic,\n        id,\n        input,\n        out,\n        typeName,\n        customEvents,\n        ownerComponentId\n      );\n\n      // This is the final input after running the lifecycle methods.\n      // We will be passing the input to the template for the `input` param\n      input = component.___updatedInput;\n    } else {\n      if (!component) {\n        if (\n          isRerender &&\n          (component = componentLookup[id]) &&\n          component.___type !== typeName\n        ) {\n          // Destroy the existing component since\n          component.destroy();\n          component = undefined;\n        }\n\n        if (component) {\n          isExisting = true;\n        } else {\n          isExisting = false;\n          // We need to create a new instance of the component\n          component = registry.___createComponent(typeName, id);\n\n          if (shouldApplySplitMixins === true) {\n            shouldApplySplitMixins = false;\n\n            var renderingLogicProps =\n              typeof renderingLogic == \"function\"\n                ? renderingLogic.prototype\n                : renderingLogic;\n\n            copyProps(renderingLogicProps, component.constructor.prototype);\n          }\n        }\n\n        // Set this flag to prevent the component from being queued for update\n        // based on the new input. The component is about to be rerendered\n        // so we don't want to queue it up as a result of calling `setInput()`\n        component.___updateQueued = true;\n\n        if (customEvents !== undefined) {\n          component.___setCustomEvents(customEvents, ownerComponentId);\n        }\n\n        if (isExisting === false) {\n          component.___emitCreate(input, out);\n        }\n\n        input = component.___setInput(input, onInput, out);\n\n        if (isExisting === true) {\n          if (\n            component.___isDirty === false ||\n            component.shouldUpdate(input, component.___state) === false\n          ) {\n            // We put a placeholder element in the output stream to ensure that the existing\n            // DOM node is matched up correctly when using morphdom. We flag the VElement\n            // node to track that it is a preserve marker\n            out.___preserveComponent(component);\n            globalComponentsContext.___renderedComponentsById[id] = true;\n            component.___reset(); // The component is no longer dirty so reset internal flags\n            return;\n          }\n        }\n      }\n\n      component.___global = out.global;\n      component.___emitRender(out);\n    }\n\n    var componentDef = beginComponent(\n      componentsContext,\n      component,\n      key,\n      ownerComponentDef,\n      isSplit,\n      isImplicitComponent\n    );\n\n    componentDef.___isExisting = isExisting;\n\n    // Render the template associated with the component using the final template\n    // data that we constructed\n    templateRenderFunc(\n      input,\n      out,\n      componentDef,\n      component,\n      component.___rawState\n    );\n\n    endComponent(out, componentDef);\n    componentsContext.___componentDef = parentComponentDef;\n  };\n}\n\nmodule.exports = createRendererFunc;\n"],"file":"renderer.js"}
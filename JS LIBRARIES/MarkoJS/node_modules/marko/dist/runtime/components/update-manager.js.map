{"version":3,"sources":["../../../src/runtime/components/update-manager.js"],"names":["updatesScheduled","batchStack","unbatchedQueue","setImmediate","require","updateUnbatchedComponents","length","updateComponents","scheduleUpdates","queue","i","component","batchUpdate","func","batch","push","queueComponentUpdate","batchStackLen","exports"],"mappings":"AAAA;;AAEA,IAAIA,gBAAgB,GAAG,KAAvB;AACA,IAAIC,UAAU,GAAG,EAAjB,C,CAAqB;AACrB,IAAIC,cAAc,GAAG,EAArB,C,CAAyB;;AAEzB,IAAIC,YAAY,GAAGC,OAAO,CAAC,iBAAD,CAA1B;;AAEA;AACA;AACA;AACA;AACA,SAASC,yBAAT,GAAqC;AACnC,MAAIH,cAAc,CAACI,MAAnB,EAA2B;AACzB,QAAI;AACFC,MAAAA,gBAAgB,CAACL,cAAD,CAAhB;AACD,KAFD,SAEU;AACR;AACA;AACA;AACAF,MAAAA,gBAAgB,GAAG,KAAnB;AACD;AACF;AACF;;AAED,SAASQ,eAAT,GAA2B;AACzB,MAAIR,gBAAJ,EAAsB;AACpB;AACA;AACA;AACD;;AAEDA,EAAAA,gBAAgB,GAAG,IAAnB;;AAEAG,EAAAA,YAAY,CAACE,yBAAD,CAAZ;AACD;;AAED,SAASE,gBAAT,CAA0BE,KAA1B,EAAiC;AAC/B;AACA;AACA;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACH,MAA1B,EAAkCI,CAAC,EAAnC,EAAuC;AACrC,QAAIC,SAAS,GAAGF,KAAK,CAACC,CAAD,CAArB;AACAC,IAAAA,SAAS,IAAT,GAFqC,CAEd;AACxB;;AAED;AACAF,EAAAA,KAAK,CAACH,MAAN,GAAe,CAAf;AACD;;AAED,SAASM,WAAT,CAAqBC,IAArB,EAA2B;AACzB;AACA;AACA;AACA;AACA,MAAIC,KAAK,GAAG;AACV,SAAU,IADA,EAAZ;;;AAIAb,EAAAA,UAAU,CAACc,IAAX,CAAgBD,KAAhB;;AAEA,MAAI;AACFD,IAAAA,IAAI;AACL,GAFD,SAEU;AACR,QAAI;AACF;AACA;AACA,UAAIC,KAAK,IAAT,EAAoB;AAClBP,QAAAA,gBAAgB,CAACO,KAAK,IAAN,CAAhB;AACD;AACF,KAND,SAMU;AACR;AACA;AACAb,MAAAA,UAAU,CAACK,MAAX;AACD;AACF;AACF;;AAED,SAASU,oBAAT,CAA8BL,SAA9B,EAAyC;AACvC,MAAIM,aAAa,GAAGhB,UAAU,CAACK,MAA/B;;AAEA,MAAIW,aAAJ,EAAmB;AACjB;AACA;AACA;AACA;AACA,QAAIH,KAAK,GAAGb,UAAU,CAACgB,aAAa,GAAG,CAAjB,CAAtB;;AAEA;AACA;AACA;AACA,QAAIH,KAAK,IAAT,EAAoB;AAClBA,MAAAA,KAAK,IAAL,CAAeC,IAAf,CAAoBJ,SAApB;AACD,KAFD,MAEO;AACLG,MAAAA,KAAK,IAAL,GAAiB,CAACH,SAAD,CAAjB;AACD;AACF,GAfD,MAeO;AACL;AACA;AACA;AACAH,IAAAA,eAAe;AACfN,IAAAA,cAAc,CAACa,IAAf,CAAoBJ,SAApB;AACD;AACF;;AAEDO,OAAO,IAAP,GAAkCF,oBAAlC;AACAE,OAAO,IAAP,GAAyBN,WAAzB","sourcesContent":["\"use strict\";\n\nvar updatesScheduled = false;\nvar batchStack = []; // A stack of batched updates\nvar unbatchedQueue = []; // Used for scheduled batched updates\n\nvar setImmediate = require(\"../setImmediate\");\n\n/**\n * This function is called when we schedule the update of \"unbatched\"\n * updates to components.\n */\nfunction updateUnbatchedComponents() {\n  if (unbatchedQueue.length) {\n    try {\n      updateComponents(unbatchedQueue);\n    } finally {\n      // Reset the flag now that this scheduled batch update\n      // is complete so that we can later schedule another\n      // batched update if needed\n      updatesScheduled = false;\n    }\n  }\n}\n\nfunction scheduleUpdates() {\n  if (updatesScheduled) {\n    // We have already scheduled a batched update for the\n    // nextTick so nothing to do\n    return;\n  }\n\n  updatesScheduled = true;\n\n  setImmediate(updateUnbatchedComponents);\n}\n\nfunction updateComponents(queue) {\n  // Loop over the components in the queue and update them.\n  // NOTE: It is okay if the queue grows during the iteration\n  //       since we will still get to them at the end\n  for (var i = 0; i < queue.length; i++) {\n    var component = queue[i];\n    component.___update(); // Do the actual component update\n  }\n\n  // Clear out the queue by setting the length to zero\n  queue.length = 0;\n}\n\nfunction batchUpdate(func) {\n  // If the batched update stack is empty then this\n  // is the outer batched update. After the outer\n  // batched update completes we invoke the \"afterUpdate\"\n  // event listeners.\n  var batch = {\n    ___queue: null\n  };\n\n  batchStack.push(batch);\n\n  try {\n    func();\n  } finally {\n    try {\n      // Update all of the components that where queued up\n      // in this batch (if any)\n      if (batch.___queue) {\n        updateComponents(batch.___queue);\n      }\n    } finally {\n      // Now that we have completed the update of all the components\n      // in this batch we need to remove it off the top of the stack\n      batchStack.length--;\n    }\n  }\n}\n\nfunction queueComponentUpdate(component) {\n  var batchStackLen = batchStack.length;\n\n  if (batchStackLen) {\n    // When a batch update is started we push a new batch on to a stack.\n    // If the stack has a non-zero length then we know that a batch has\n    // been started so we can just queue the component on the top batch. When\n    // the batch is ended this component will be updated.\n    var batch = batchStack[batchStackLen - 1];\n\n    // We default the batch queue to null to avoid creating an Array instance\n    // unnecessarily. If it is null then we create a new Array, otherwise\n    // we push it onto the existing Array queue\n    if (batch.___queue) {\n      batch.___queue.push(component);\n    } else {\n      batch.___queue = [component];\n    }\n  } else {\n    // We are not within a batched update. We need to schedule a batch update\n    // for the nextTick (if that hasn't been done already) and we will\n    // add the component to the unbatched queued\n    scheduleUpdates();\n    unbatchedQueue.push(component);\n  }\n}\n\nexports.___queueComponentUpdate = queueComponentUpdate;\nexports.___batchUpdate = batchUpdate;\n"],"file":"update-manager.js"}
{"version":3,"sources":["../../../../src/runtime/vdom/morphdom/index.js"],"names":["specialElHandlers","require","KeySequence","componentsUtil","existingComponentLookup","destroyNodeRecursive","addComponentRootToKeyedElements","normalizeComponentKey","VElement","virtualizeElement","morphAttrs","eventDelegation","fragment","helpers","domData","keysByDOMNode","componentByDOMNode","vElementByDOMNode","detachedByDOMNode","insertBefore","insertAfter","nextSibling","firstChild","removeChild","createFragmentNode","beginFragmentNode","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","COMPONENT_NODE","FRAGMENT_NODE","DOCTYPE_NODE","isAutoKey","key","compareNodeNames","fromEl","toEl","caseInsensitiveCompare","a","b","toLowerCase","onNodeAdded","node","componentsContext","nodeType","morphdom","fromNode","toNode","doc","globalComponentsContext","isHydrate","keySequences","Object","create","insertVirtualNodeBefore","vNode","referenceEl","parentEl","ownerComponent","parentComponent","realNode","namespaceURI","set","morphChildren","insertVirtualComponentBefore","vComponent","referenceNode","referenceNodeParentEl","component","rootNode","id","morphComponent","detachedNodes","detachNode","parentNode","push","destroyComponent","destroy","curFromNodeChild","curToNodeChild","curToNodeKey","curFromNodeKey","curToNodeType","fromNextSibling","toNextSibling","matchingFromEl","matchingFromComponent","curVFromNodeChild","fromComponent","outer","referenceComponent","undefined","get","curToNodeKeyOriginal","morphEl","nodeName","content","nodeValue","endNode","depth","indexOf","curFromNodeType","isCompatible","splitText","length","fragmentBoundary","vFromEl","constId","specialElHandler","forEach","detachedFromComponent","componentToDestroy","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nvar specialElHandlers = require(\"./specialElHandlers\");\nvar KeySequence = require(\"../../components/KeySequence\");\nvar componentsUtil = require(\"../../components/util\");\nvar existingComponentLookup = componentsUtil.___componentLookup;\nvar destroyNodeRecursive = componentsUtil.___destroyNodeRecursive;\nvar addComponentRootToKeyedElements =\n  componentsUtil.___addComponentRootToKeyedElements;\nvar normalizeComponentKey = componentsUtil.___normalizeComponentKey;\nvar VElement = require(\"../vdom\").___VElement;\nvar virtualizeElement = VElement.___virtualize;\nvar morphAttrs = VElement.___morphAttrs;\nvar eventDelegation = require(\"../../components/event-delegation\");\nvar fragment = require(\"./fragment\");\nvar helpers = require(\"./helpers\");\nvar domData = require(\"../../components/dom-data\");\nvar keysByDOMNode = domData.___keyByDOMNode;\nvar componentByDOMNode = domData.___componentByDOMNode;\nvar vElementByDOMNode = domData.___vElementByDOMNode;\nvar detachedByDOMNode = domData.___detachedByDOMNode;\n\nvar insertBefore = helpers.___insertBefore;\nvar insertAfter = helpers.___insertAfter;\nvar nextSibling = helpers.___nextSibling;\nvar firstChild = helpers.___firstChild;\nvar removeChild = helpers.___removeChild;\nvar createFragmentNode = fragment.___createFragmentNode;\nvar beginFragmentNode = fragment.___beginFragmentNode;\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar COMPONENT_NODE = 2;\nvar FRAGMENT_NODE = 12;\nvar DOCTYPE_NODE = 10;\n\n// var FLAG_SIMPLE_ATTRS = 1;\n// var FLAG_CUSTOM_ELEMENT = 2;\n// var FLAG_SPREAD_ATTRS = 4;\n\nfunction isAutoKey(key) {\n  return key[0] !== \"@\";\n}\n\nfunction compareNodeNames(fromEl, toEl) {\n  return fromEl.___nodeName === toEl.___nodeName;\n}\n\nfunction caseInsensitiveCompare(a, b) {\n  return a.toLowerCase() === b.toLowerCase();\n}\n\nfunction onNodeAdded(node, componentsContext) {\n  if (node.nodeType === ELEMENT_NODE) {\n    eventDelegation.___handleNodeAttach(node, componentsContext);\n  }\n}\n\nfunction morphdom(fromNode, toNode, doc, componentsContext) {\n  var globalComponentsContext;\n  var isHydrate = false;\n  var keySequences = Object.create(null);\n\n  if (componentsContext) {\n    globalComponentsContext = componentsContext.___globalContext;\n    isHydrate = globalComponentsContext.___isHydrate;\n  }\n\n  function insertVirtualNodeBefore(\n    vNode,\n    key,\n    referenceEl,\n    parentEl,\n    ownerComponent,\n    parentComponent\n  ) {\n    var realNode = vNode.___actualize(doc, parentEl.namespaceURI);\n    insertBefore(realNode, referenceEl, parentEl);\n\n    if (\n      vNode.___nodeType === ELEMENT_NODE ||\n      vNode.___nodeType === FRAGMENT_NODE\n    ) {\n      if (key) {\n        keysByDOMNode.set(realNode, key);\n        (isAutoKey(key) ? parentComponent : ownerComponent).___keyedElements[\n          key\n        ] = realNode;\n      }\n\n      if (vNode.___nodeName !== \"textarea\") {\n        morphChildren(realNode, vNode, parentComponent);\n      }\n\n      onNodeAdded(realNode, componentsContext);\n    }\n  }\n\n  function insertVirtualComponentBefore(\n    vComponent,\n    referenceNode,\n    referenceNodeParentEl,\n    component,\n    key,\n    ownerComponent,\n    parentComponent\n  ) {\n    var rootNode = (component.___rootNode = insertBefore(\n      createFragmentNode(),\n      referenceNode,\n      referenceNodeParentEl\n    ));\n    componentByDOMNode.set(rootNode, component);\n\n    if (key && ownerComponent) {\n      key = normalizeComponentKey(key, parentComponent.id);\n      addComponentRootToKeyedElements(\n        ownerComponent.___keyedElements,\n        key,\n        rootNode,\n        component.id\n      );\n      keysByDOMNode.set(rootNode, key);\n    }\n\n    morphComponent(component, vComponent);\n  }\n\n  function morphComponent(component, vComponent) {\n    morphChildren(component.___rootNode, vComponent, component);\n  }\n\n  var detachedNodes = [];\n\n  function detachNode(node, parentNode, ownerComponent) {\n    if (node.nodeType === ELEMENT_NODE || node.nodeType === FRAGMENT_NODE) {\n      detachedNodes.push(node);\n      detachedByDOMNode.set(node, ownerComponent || true);\n    } else {\n      destroyNodeRecursive(node);\n      removeChild(node);\n    }\n  }\n\n  function destroyComponent(component) {\n    component.destroy();\n  }\n\n  function morphChildren(fromNode, toNode, parentComponent) {\n    var curFromNodeChild = firstChild(fromNode);\n    var curToNodeChild = toNode.___firstChild;\n\n    var curToNodeKey;\n    var curFromNodeKey;\n    var curToNodeType;\n\n    var fromNextSibling;\n    var toNextSibling;\n    var matchingFromEl;\n    var matchingFromComponent;\n    var curVFromNodeChild;\n    var fromComponent;\n\n    outer: while (curToNodeChild) {\n      toNextSibling = curToNodeChild.___nextSibling;\n      curToNodeType = curToNodeChild.___nodeType;\n      curToNodeKey = curToNodeChild.___key;\n\n      // Skip <!doctype>\n      if (curFromNodeChild && curFromNodeChild.nodeType === DOCTYPE_NODE) {\n        curFromNodeChild = nextSibling(curFromNodeChild);\n      }\n\n      var ownerComponent = curToNodeChild.___ownerComponent || parentComponent;\n      var referenceComponent;\n\n      if (curToNodeType === COMPONENT_NODE) {\n        var component = curToNodeChild.___component;\n        if (\n          (matchingFromComponent = existingComponentLookup[component.id]) ===\n          undefined\n        ) {\n          if (isHydrate === true) {\n            var rootNode = beginFragmentNode(curFromNodeChild, fromNode);\n            component.___rootNode = rootNode;\n            componentByDOMNode.set(rootNode, component);\n\n            if (ownerComponent && curToNodeKey) {\n              curToNodeKey = normalizeComponentKey(\n                curToNodeKey,\n                parentComponent.id\n              );\n              addComponentRootToKeyedElements(\n                ownerComponent.___keyedElements,\n                curToNodeKey,\n                rootNode,\n                component.id\n              );\n\n              keysByDOMNode.set(rootNode, curToNodeKey);\n            }\n\n            morphComponent(component, curToNodeChild);\n\n            curFromNodeChild = nextSibling(rootNode);\n          } else {\n            insertVirtualComponentBefore(\n              curToNodeChild,\n              curFromNodeChild,\n              fromNode,\n              component,\n              curToNodeKey,\n              ownerComponent,\n              parentComponent\n            );\n          }\n        } else {\n          if (matchingFromComponent.___rootNode !== curFromNodeChild) {\n            if (\n              curFromNodeChild &&\n              (fromComponent = componentByDOMNode.get(curFromNodeChild)) &&\n              globalComponentsContext.___renderedComponentsById[\n                fromComponent.id\n              ] === undefined\n            ) {\n              // The component associated with the current real DOM node was not rendered\n              // so we should just remove it out of the real DOM by destroying it\n              curFromNodeChild = nextSibling(fromComponent.___rootNode);\n              destroyComponent(fromComponent);\n              continue;\n            }\n\n            // We need to move the existing component into\n            // the correct location\n            insertBefore(\n              matchingFromComponent.___rootNode,\n              curFromNodeChild,\n              fromNode\n            );\n          } else {\n            curFromNodeChild =\n              curFromNodeChild && nextSibling(curFromNodeChild);\n          }\n\n          if (!curToNodeChild.___preserve) {\n            morphComponent(component, curToNodeChild);\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        continue;\n      } else if (curToNodeKey) {\n        curVFromNodeChild = undefined;\n        curFromNodeKey = undefined;\n        var curToNodeKeyOriginal = curToNodeKey;\n\n        if (isAutoKey(curToNodeKey)) {\n          if (ownerComponent !== parentComponent) {\n            curToNodeKey += \":\" + ownerComponent.id;\n          }\n          referenceComponent = parentComponent;\n        } else {\n          referenceComponent = ownerComponent;\n        }\n\n        // We have a keyed element. This is the fast path for matching\n        // up elements\n        curToNodeKey = (\n          keySequences[referenceComponent.id] ||\n          (keySequences[referenceComponent.id] = new KeySequence())\n        ).___nextKey(curToNodeKey);\n\n        if (curFromNodeChild) {\n          curFromNodeKey = keysByDOMNode.get(curFromNodeChild);\n          curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n          fromNextSibling = nextSibling(curFromNodeChild);\n        }\n\n        if (curFromNodeKey === curToNodeKey) {\n          // Elements line up. Now we just have to make sure they are compatible\n          if (!curToNodeChild.___preserve) {\n            // We just skip over the fromNode if it is preserved\n\n            if (compareNodeNames(curToNodeChild, curVFromNodeChild)) {\n              morphEl(\n                curFromNodeChild,\n                curVFromNodeChild,\n                curToNodeChild,\n                parentComponent\n              );\n            } else {\n              // Remove the old node\n              detachNode(curFromNodeChild, fromNode, ownerComponent);\n\n              // Incompatible nodes. Just move the target VNode into the DOM at this position\n              insertVirtualNodeBefore(\n                curToNodeChild,\n                curToNodeKey,\n                curFromNodeChild,\n                fromNode,\n                ownerComponent,\n                parentComponent\n              );\n            }\n          }\n        } else {\n          matchingFromEl = referenceComponent.___keyedElements[curToNodeKey];\n          if (\n            matchingFromEl === undefined ||\n            matchingFromEl === curFromNodeChild\n          ) {\n            if (isHydrate === true && curFromNodeChild) {\n              if (\n                curFromNodeChild.nodeType === ELEMENT_NODE &&\n                (curToNodeChild.___preserve ||\n                  caseInsensitiveCompare(\n                    curFromNodeChild.nodeName,\n                    curToNodeChild.___nodeName || \"\"\n                  ))\n              ) {\n                curVFromNodeChild = virtualizeElement(curFromNodeChild);\n                curVFromNodeChild.___nodeName = curToNodeChild.___nodeName;\n                keysByDOMNode.set(curFromNodeChild, curToNodeKey);\n                referenceComponent.___keyedElements[curToNodeKey] =\n                  curFromNodeChild;\n\n                if (curToNodeChild.___preserve) {\n                  vElementByDOMNode.set(curFromNodeChild, curVFromNodeChild);\n                } else {\n                  morphEl(\n                    curFromNodeChild,\n                    curVFromNodeChild,\n                    curToNodeChild,\n                    parentComponent\n                  );\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n                continue;\n              } else if (\n                curToNodeChild.___nodeType === FRAGMENT_NODE &&\n                curFromNodeChild.nodeType === COMMENT_NODE\n              ) {\n                var content = curFromNodeChild.nodeValue;\n                if (content == \"F#\" + curToNodeKeyOriginal) {\n                  var endNode = curFromNodeChild.nextSibling;\n                  var depth = 0;\n                  var nodeValue;\n\n                  // eslint-disable-next-line no-constant-condition\n                  while (true) {\n                    if (endNode.nodeType === COMMENT_NODE) {\n                      nodeValue = endNode.nodeValue;\n                      if (nodeValue === \"F/\") {\n                        if (depth === 0) {\n                          break;\n                        } else {\n                          depth--;\n                        }\n                      } else if (nodeValue.indexOf(\"F#\") === 0) {\n                        depth++;\n                      }\n                    }\n                    endNode = endNode.nextSibling;\n                  }\n\n                  var fragment = createFragmentNode(\n                    curFromNodeChild,\n                    endNode.nextSibling,\n                    fromNode\n                  );\n                  keysByDOMNode.set(fragment, curToNodeKey);\n                  vElementByDOMNode.set(fragment, curToNodeChild);\n                  referenceComponent.___keyedElements[curToNodeKey] = fragment;\n                  removeChild(curFromNodeChild);\n                  removeChild(endNode);\n\n                  if (!curToNodeChild.___preserve) {\n                    morphChildren(fragment, curToNodeChild, parentComponent);\n                  }\n\n                  curToNodeChild = toNextSibling;\n                  curFromNodeChild = fragment.nextSibling;\n                  continue;\n                }\n              }\n            }\n\n            insertVirtualNodeBefore(\n              curToNodeChild,\n              curToNodeKey,\n              curFromNodeChild,\n              fromNode,\n              ownerComponent,\n              parentComponent\n            );\n            fromNextSibling = curFromNodeChild;\n          } else {\n            if (detachedByDOMNode.get(matchingFromEl) !== undefined) {\n              detachedByDOMNode.set(matchingFromEl, undefined);\n            }\n\n            if (!curToNodeChild.___preserve) {\n              curVFromNodeChild = vElementByDOMNode.get(matchingFromEl);\n\n              if (compareNodeNames(curVFromNodeChild, curToNodeChild)) {\n                if (fromNextSibling === matchingFromEl) {\n                  // Single element removal:\n                  // A <-> A\n                  // B <-> C <-- We are here\n                  // C     D\n                  // D\n                  //\n                  // Single element swap:\n                  // A <-> A\n                  // B <-> C <-- We are here\n                  // C     B\n\n                  if (\n                    toNextSibling &&\n                    toNextSibling.___key === curFromNodeKey\n                  ) {\n                    // Single element swap\n\n                    // We want to stay on the current real DOM node\n                    fromNextSibling = curFromNodeChild;\n\n                    // But move the matching element into place\n                    insertBefore(matchingFromEl, curFromNodeChild, fromNode);\n                  } else {\n                    // Single element removal\n\n                    // We need to remove the current real DOM node\n                    // and the matching real DOM node will fall into\n                    // place. We will continue diffing with next sibling\n                    // after the real DOM node that just fell into place\n                    fromNextSibling = nextSibling(fromNextSibling);\n\n                    if (curFromNodeChild) {\n                      detachNode(curFromNodeChild, fromNode, ownerComponent);\n                    }\n                  }\n                } else {\n                  // A <-> A\n                  // B <-> D <-- We are here\n                  // C\n                  // D\n\n                  // We need to move the matching node into place\n                  insertAfter(matchingFromEl, curFromNodeChild, fromNode);\n\n                  if (curFromNodeChild) {\n                    detachNode(curFromNodeChild, fromNode, ownerComponent);\n                  }\n                }\n\n                morphEl(\n                  matchingFromEl,\n                  curVFromNodeChild,\n                  curToNodeChild,\n                  parentComponent\n                );\n              } else {\n                insertVirtualNodeBefore(\n                  curToNodeChild,\n                  curToNodeKey,\n                  curFromNodeChild,\n                  fromNode,\n                  ownerComponent,\n                  parentComponent\n                );\n                detachNode(matchingFromEl, fromNode, ownerComponent);\n              }\n            } else {\n              // preserve the node\n              // but still we need to diff the current from node\n              insertBefore(matchingFromEl, curFromNodeChild, fromNode);\n              fromNextSibling = curFromNodeChild;\n            }\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        curFromNodeChild = fromNextSibling;\n        continue;\n      }\n\n      // The know the target node is not a VComponent node and we know\n      // it is also not a preserve node. Let's now match up the HTML\n      // element, text node, comment, etc.\n      while (curFromNodeChild) {\n        fromNextSibling = nextSibling(curFromNodeChild);\n\n        if ((fromComponent = componentByDOMNode.get(curFromNodeChild))) {\n          // The current \"to\" element is not associated with a component,\n          // but the current \"from\" element is associated with a component\n\n          // Even if we destroy the current component in the original\n          // DOM or not, we still need to skip over it since it is\n          // not compatible with the current \"to\" node\n          curFromNodeChild = fromNextSibling;\n\n          if (\n            !globalComponentsContext.___renderedComponentsById[fromComponent.id]\n          ) {\n            destroyComponent(fromComponent);\n          }\n\n          continue; // Move to the next \"from\" node\n        }\n\n        var curFromNodeType = curFromNodeChild.nodeType;\n\n        var isCompatible = undefined;\n\n        if (curFromNodeType === curToNodeType) {\n          if (curFromNodeType === ELEMENT_NODE) {\n            // Both nodes being compared are Element nodes\n            curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n            if (curVFromNodeChild === undefined) {\n              if (isHydrate === true) {\n                curVFromNodeChild = virtualizeElement(curFromNodeChild);\n\n                if (\n                  caseInsensitiveCompare(\n                    curVFromNodeChild.___nodeName,\n                    curToNodeChild.___nodeName\n                  )\n                ) {\n                  curVFromNodeChild.___nodeName = curToNodeChild.___nodeName;\n                }\n              } else {\n                // Skip over nodes that don't look like ours...\n                curFromNodeChild = fromNextSibling;\n                continue;\n              }\n            } else if ((curFromNodeKey = curVFromNodeChild.___key)) {\n              // We have a keyed element here but our target VDOM node\n              // is not keyed so this not doesn't belong\n              isCompatible = false;\n            }\n\n            isCompatible =\n              isCompatible !== false &&\n              compareNodeNames(curVFromNodeChild, curToNodeChild) === true;\n\n            if (isCompatible === true) {\n              // We found compatible DOM elements so transform\n              // the current \"from\" node to match the current\n              // target DOM node.\n              morphEl(\n                curFromNodeChild,\n                curVFromNodeChild,\n                curToNodeChild,\n                parentComponent\n              );\n            }\n          } else if (\n            curFromNodeType === TEXT_NODE ||\n            curFromNodeType === COMMENT_NODE\n          ) {\n            // Both nodes being compared are Text or Comment nodes\n            isCompatible = true;\n            // Simply update nodeValue on the original node to\n            // change the text value\n\n            if (\n              isHydrate === true &&\n              toNextSibling &&\n              curFromNodeType === TEXT_NODE &&\n              toNextSibling.___nodeType === TEXT_NODE\n            ) {\n              fromNextSibling = curFromNodeChild.splitText(\n                curToNodeChild.___nodeValue.length\n              );\n            }\n            if (curFromNodeChild.nodeValue !== curToNodeChild.___nodeValue) {\n              curFromNodeChild.nodeValue = curToNodeChild.___nodeValue;\n            }\n          }\n        }\n\n        if (isCompatible === true) {\n          // Advance both the \"to\" child and the \"from\" child since we found a match\n          curToNodeChild = toNextSibling;\n          curFromNodeChild = fromNextSibling;\n          continue outer;\n        }\n\n        detachNode(curFromNodeChild, fromNode, ownerComponent);\n        curFromNodeChild = fromNextSibling;\n      } // END: while (curFromNodeChild)\n\n      // If we got this far then we did not find a candidate match for\n      // our \"to node\" and we exhausted all of the children \"from\"\n      // nodes. Therefore, we will just append the current \"to\" node\n      // to the end\n      insertVirtualNodeBefore(\n        curToNodeChild,\n        curToNodeKey,\n        curFromNodeChild,\n        fromNode,\n        ownerComponent,\n        parentComponent\n      );\n\n      curToNodeChild = toNextSibling;\n      curFromNodeChild = fromNextSibling;\n    }\n\n    // We have processed all of the \"to nodes\".\n    if (fromNode.___finishFragment) {\n      // If we are in an unfinished fragment, we have reached the end of the nodes\n      // we were matching up and need to end the fragment\n      fromNode.___finishFragment(curFromNodeChild);\n    } else {\n      // If curFromNodeChild is non-null then we still have some from nodes\n      // left over that need to be removed\n      var fragmentBoundary =\n        fromNode.nodeType === FRAGMENT_NODE ? fromNode.endNode : null;\n\n      while (curFromNodeChild && curFromNodeChild !== fragmentBoundary) {\n        fromNextSibling = nextSibling(curFromNodeChild);\n\n        if ((fromComponent = componentByDOMNode.get(curFromNodeChild))) {\n          curFromNodeChild = fromNextSibling;\n          if (\n            !globalComponentsContext.___renderedComponentsById[fromComponent.id]\n          ) {\n            destroyComponent(fromComponent);\n          }\n          continue;\n        }\n\n        curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n        curFromNodeKey = keysByDOMNode.get(fromNode);\n\n        // For transcluded content, we need to check if the element belongs to a different component\n        // context than the current component and ensure it gets removed from its key index.\n        if (!curFromNodeKey || isAutoKey(curFromNodeKey)) {\n          referenceComponent = parentComponent;\n        } else {\n          referenceComponent =\n            curVFromNodeChild && curVFromNodeChild.___ownerComponent;\n        }\n\n        detachNode(curFromNodeChild, fromNode, referenceComponent);\n\n        curFromNodeChild = fromNextSibling;\n      }\n    }\n  }\n\n  function morphEl(fromEl, vFromEl, toEl, parentComponent) {\n    var nodeName = toEl.___nodeName;\n\n    var constId = toEl.___constId;\n    if (constId !== undefined && vFromEl.___constId === constId) {\n      return;\n    }\n\n    morphAttrs(fromEl, vFromEl, toEl);\n\n    if (toEl.___preserveBody) {\n      return;\n    }\n\n    if (nodeName !== \"textarea\") {\n      morphChildren(fromEl, toEl, parentComponent);\n    }\n\n    var specialElHandler = specialElHandlers[nodeName];\n    if (specialElHandler !== undefined) {\n      specialElHandler(fromEl, toEl);\n    }\n  } // END: morphEl(...)\n\n  // eslint-disable-next-line no-constant-condition\n  if (\"MARKO_DEBUG\") {\n    componentsUtil.___stopDOMManipulationWarning();\n  }\n\n  morphChildren(fromNode, toNode, toNode.___component);\n\n  detachedNodes.forEach(function (node) {\n    var detachedFromComponent = detachedByDOMNode.get(node);\n\n    if (detachedFromComponent !== undefined) {\n      detachedByDOMNode.set(node, undefined);\n\n      var componentToDestroy = componentByDOMNode.get(node);\n      if (componentToDestroy) {\n        componentToDestroy.destroy();\n      } else if (node.parentNode) {\n        destroyNodeRecursive(\n          node,\n          detachedFromComponent !== true && detachedFromComponent\n        );\n\n        if (eventDelegation.___handleNodeDetach(node) != false) {\n          removeChild(node);\n        }\n      }\n    }\n  });\n\n  // eslint-disable-next-line no-constant-condition\n  if (\"MARKO_DEBUG\") {\n    componentsUtil.___startDOMManipulationWarning();\n  }\n}\n\nmodule.exports = morphdom;\n"],"file":"index.js"}